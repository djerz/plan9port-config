diff --git a/src/cmd/devdraw/mkwsysrules.sh b/src/cmd/devdraw/mkwsysrules.sh
index 56dff55a..c9d2d17f 100644
--- a/src/cmd/devdraw/mkwsysrules.sh
+++ b/src/cmd/devdraw/mkwsysrules.sh
@@ -2,7 +2,7 @@
 
 [ -f $PLAN9/config ] && . $PLAN9/config
 
-if [ "x$X11" = "x" ]; then 
+if [ "x$X11" = "x" ]; then
 	if [ -d /usr/X11R6 ]; then
 		X11=/usr/X11R6
 	elif [ -d /usr/local/X11R6 ]; then
@@ -29,6 +29,8 @@ if [ "x$WSYSTYPE" = "x" ]; then
 			exit 1
 		fi
 		WSYSTYPE=mac
+	elif [ "x$XDG_SESSION_TYPE" = "xwayland" ]; then
+		WSYSTYPE=wayland
 	elif [ -d "$X11" ]; then
 		WSYSTYPE=x11
 	else
@@ -43,7 +45,7 @@ if [ "x$WSYSTYPE" = "xx11" -a "x$X11H" = "x" ]; then
 		X11H=""
 	fi
 fi
-	
+
 echo 'WSYSTYPE='$WSYSTYPE
 echo 'X11='$X11
 echo 'X11H='$X11H
@@ -58,6 +60,12 @@ elif [ $WSYSTYPE = mac ]; then
 	echo 'WSYSOFILES=$WSYSOFILES mac-draw.o mac-screen.o'
 	echo 'WSYSHFILES='
 	echo 'MACARGV=macargv.o'
+elif [ $WSYSTYPE = wayland ]; then
+	echo 'LDFLAGS=$LDFLAGS -lwayland-client -lxkbcommon'
+	XO=`ls wayland*.c 2>/dev/null | sed 's/\.c/\.o/'`
+	echo 'WSYSOFILES=$WSYSOFILES '$XO
+	XH=`ls wayland*.h 2>/dev/null`
+	echo 'WSYSHFILES='$XH
 elif [ $WSYSTYPE = nowsys ]; then
 	echo 'WSYSOFILES=nowsys.o'
 fi
diff --git a/src/cmd/devdraw/wayland-pointer-constraints.c b/src/cmd/devdraw/wayland-pointer-constraints.c
new file mode 100644
index 00000000..6343d909
--- /dev/null
+++ b/src/cmd/devdraw/wayland-pointer-constraints.c
@@ -0,0 +1,99 @@
+/* Generated by wayland-scanner 1.23.0 */
+
+/*
+ * Copyright © 2014      Jonas Ådahl
+ * Copyright © 2015      Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_pointer_interface;
+extern const struct wl_interface wl_region_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface zwp_confined_pointer_v1_interface;
+extern const struct wl_interface zwp_locked_pointer_v1_interface;
+
+static const struct wl_interface *pointer_constraints_unstable_v1_types[] = {
+	NULL,
+	NULL,
+	&zwp_locked_pointer_v1_interface,
+	&wl_surface_interface,
+	&wl_pointer_interface,
+	&wl_region_interface,
+	NULL,
+	&zwp_confined_pointer_v1_interface,
+	&wl_surface_interface,
+	&wl_pointer_interface,
+	&wl_region_interface,
+	NULL,
+	&wl_region_interface,
+	&wl_region_interface,
+};
+
+static const struct wl_message zwp_pointer_constraints_v1_requests[] = {
+	{ "destroy", "", pointer_constraints_unstable_v1_types + 0 },
+	{ "lock_pointer", "noo?ou", pointer_constraints_unstable_v1_types + 2 },
+	{ "confine_pointer", "noo?ou", pointer_constraints_unstable_v1_types + 7 },
+};
+
+WL_EXPORT const struct wl_interface zwp_pointer_constraints_v1_interface = {
+	"zwp_pointer_constraints_v1", 1,
+	3, zwp_pointer_constraints_v1_requests,
+	0, NULL,
+};
+
+static const struct wl_message zwp_locked_pointer_v1_requests[] = {
+	{ "destroy", "", pointer_constraints_unstable_v1_types + 0 },
+	{ "set_cursor_position_hint", "ff", pointer_constraints_unstable_v1_types + 0 },
+	{ "set_region", "?o", pointer_constraints_unstable_v1_types + 12 },
+};
+
+static const struct wl_message zwp_locked_pointer_v1_events[] = {
+	{ "locked", "", pointer_constraints_unstable_v1_types + 0 },
+	{ "unlocked", "", pointer_constraints_unstable_v1_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_locked_pointer_v1_interface = {
+	"zwp_locked_pointer_v1", 1,
+	3, zwp_locked_pointer_v1_requests,
+	2, zwp_locked_pointer_v1_events,
+};
+
+static const struct wl_message zwp_confined_pointer_v1_requests[] = {
+	{ "destroy", "", pointer_constraints_unstable_v1_types + 0 },
+	{ "set_region", "?o", pointer_constraints_unstable_v1_types + 13 },
+};
+
+static const struct wl_message zwp_confined_pointer_v1_events[] = {
+	{ "confined", "", pointer_constraints_unstable_v1_types + 0 },
+	{ "unconfined", "", pointer_constraints_unstable_v1_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_confined_pointer_v1_interface = {
+	"zwp_confined_pointer_v1", 1,
+	2, zwp_confined_pointer_v1_requests,
+	2, zwp_confined_pointer_v1_events,
+};
+
diff --git a/src/cmd/devdraw/wayland-pointer-constraints.h b/src/cmd/devdraw/wayland-pointer-constraints.h
new file mode 100644
index 00000000..50740a2a
--- /dev/null
+++ b/src/cmd/devdraw/wayland-pointer-constraints.h
@@ -0,0 +1,667 @@
+/* Generated by wayland-scanner 1.23.0 */
+
+#ifndef POINTER_CONSTRAINTS_UNSTABLE_V1_CLIENT_PROTOCOL_H
+#define POINTER_CONSTRAINTS_UNSTABLE_V1_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_pointer_constraints_unstable_v1 The pointer_constraints_unstable_v1 protocol
+ * protocol for constraining pointer motions
+ *
+ * @section page_desc_pointer_constraints_unstable_v1 Description
+ *
+ * This protocol specifies a set of interfaces used for adding constraints to
+ * the motion of a pointer. Possible constraints include confining pointer
+ * motions to a given region, or locking it to its current position.
+ *
+ * In order to constrain the pointer, a client must first bind the global
+ * interface "wp_pointer_constraints" which, if a compositor supports pointer
+ * constraints, is exposed by the registry. Using the bound global object, the
+ * client uses the request that corresponds to the type of constraint it wants
+ * to make. See wp_pointer_constraints for more details.
+ *
+ * Warning! The protocol described in this file is experimental and backward
+ * incompatible changes may be made. Backward compatible changes may be added
+ * together with the corresponding interface version bump. Backward
+ * incompatible changes are done by bumping the version number in the protocol
+ * and interface names and resetting the interface version. Once the protocol
+ * is to be declared stable, the 'z' prefix and the version number in the
+ * protocol and interface names are removed and the interface version number is
+ * reset.
+ *
+ * @section page_ifaces_pointer_constraints_unstable_v1 Interfaces
+ * - @subpage page_iface_zwp_pointer_constraints_v1 - constrain the movement of a pointer
+ * - @subpage page_iface_zwp_locked_pointer_v1 - receive relative pointer motion events
+ * - @subpage page_iface_zwp_confined_pointer_v1 - confined pointer object
+ * @section page_copyright_pointer_constraints_unstable_v1 Copyright
+ * <pre>
+ *
+ * Copyright © 2014      Jonas Ådahl
+ * Copyright © 2015      Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_pointer;
+struct wl_region;
+struct wl_surface;
+struct zwp_confined_pointer_v1;
+struct zwp_locked_pointer_v1;
+struct zwp_pointer_constraints_v1;
+
+#ifndef ZWP_POINTER_CONSTRAINTS_V1_INTERFACE
+#define ZWP_POINTER_CONSTRAINTS_V1_INTERFACE
+/**
+ * @page page_iface_zwp_pointer_constraints_v1 zwp_pointer_constraints_v1
+ * @section page_iface_zwp_pointer_constraints_v1_desc Description
+ *
+ * The global interface exposing pointer constraining functionality. It
+ * exposes two requests: lock_pointer for locking the pointer to its
+ * position, and confine_pointer for locking the pointer to a region.
+ *
+ * The lock_pointer and confine_pointer requests create the objects
+ * wp_locked_pointer and wp_confined_pointer respectively, and the client can
+ * use these objects to interact with the lock.
+ *
+ * For any surface, only one lock or confinement may be active across all
+ * wl_pointer objects of the same seat. If a lock or confinement is requested
+ * when another lock or confinement is active or requested on the same surface
+ * and with any of the wl_pointer objects of the same seat, an
+ * 'already_constrained' error will be raised.
+ * @section page_iface_zwp_pointer_constraints_v1_api API
+ * See @ref iface_zwp_pointer_constraints_v1.
+ */
+/**
+ * @defgroup iface_zwp_pointer_constraints_v1 The zwp_pointer_constraints_v1 interface
+ *
+ * The global interface exposing pointer constraining functionality. It
+ * exposes two requests: lock_pointer for locking the pointer to its
+ * position, and confine_pointer for locking the pointer to a region.
+ *
+ * The lock_pointer and confine_pointer requests create the objects
+ * wp_locked_pointer and wp_confined_pointer respectively, and the client can
+ * use these objects to interact with the lock.
+ *
+ * For any surface, only one lock or confinement may be active across all
+ * wl_pointer objects of the same seat. If a lock or confinement is requested
+ * when another lock or confinement is active or requested on the same surface
+ * and with any of the wl_pointer objects of the same seat, an
+ * 'already_constrained' error will be raised.
+ */
+extern const struct wl_interface zwp_pointer_constraints_v1_interface;
+#endif
+#ifndef ZWP_LOCKED_POINTER_V1_INTERFACE
+#define ZWP_LOCKED_POINTER_V1_INTERFACE
+/**
+ * @page page_iface_zwp_locked_pointer_v1 zwp_locked_pointer_v1
+ * @section page_iface_zwp_locked_pointer_v1_desc Description
+ *
+ * The wp_locked_pointer interface represents a locked pointer state.
+ *
+ * While the lock of this object is active, the wl_pointer objects of the
+ * associated seat will not emit any wl_pointer.motion events.
+ *
+ * This object will send the event 'locked' when the lock is activated.
+ * Whenever the lock is activated, it is guaranteed that the locked surface
+ * will already have received pointer focus and that the pointer will be
+ * within the region passed to the request creating this object.
+ *
+ * To unlock the pointer, send the destroy request. This will also destroy
+ * the wp_locked_pointer object.
+ *
+ * If the compositor decides to unlock the pointer the unlocked event is
+ * sent. See wp_locked_pointer.unlock for details.
+ *
+ * When unlocking, the compositor may warp the cursor position to the set
+ * cursor position hint. If it does, it will not result in any relative
+ * motion events emitted via wp_relative_pointer.
+ *
+ * If the surface the lock was requested on is destroyed and the lock is not
+ * yet activated, the wp_locked_pointer object is now defunct and must be
+ * destroyed.
+ * @section page_iface_zwp_locked_pointer_v1_api API
+ * See @ref iface_zwp_locked_pointer_v1.
+ */
+/**
+ * @defgroup iface_zwp_locked_pointer_v1 The zwp_locked_pointer_v1 interface
+ *
+ * The wp_locked_pointer interface represents a locked pointer state.
+ *
+ * While the lock of this object is active, the wl_pointer objects of the
+ * associated seat will not emit any wl_pointer.motion events.
+ *
+ * This object will send the event 'locked' when the lock is activated.
+ * Whenever the lock is activated, it is guaranteed that the locked surface
+ * will already have received pointer focus and that the pointer will be
+ * within the region passed to the request creating this object.
+ *
+ * To unlock the pointer, send the destroy request. This will also destroy
+ * the wp_locked_pointer object.
+ *
+ * If the compositor decides to unlock the pointer the unlocked event is
+ * sent. See wp_locked_pointer.unlock for details.
+ *
+ * When unlocking, the compositor may warp the cursor position to the set
+ * cursor position hint. If it does, it will not result in any relative
+ * motion events emitted via wp_relative_pointer.
+ *
+ * If the surface the lock was requested on is destroyed and the lock is not
+ * yet activated, the wp_locked_pointer object is now defunct and must be
+ * destroyed.
+ */
+extern const struct wl_interface zwp_locked_pointer_v1_interface;
+#endif
+#ifndef ZWP_CONFINED_POINTER_V1_INTERFACE
+#define ZWP_CONFINED_POINTER_V1_INTERFACE
+/**
+ * @page page_iface_zwp_confined_pointer_v1 zwp_confined_pointer_v1
+ * @section page_iface_zwp_confined_pointer_v1_desc Description
+ *
+ * The wp_confined_pointer interface represents a confined pointer state.
+ *
+ * This object will send the event 'confined' when the confinement is
+ * activated. Whenever the confinement is activated, it is guaranteed that
+ * the surface the pointer is confined to will already have received pointer
+ * focus and that the pointer will be within the region passed to the request
+ * creating this object. It is up to the compositor to decide whether this
+ * requires some user interaction and if the pointer will warp to within the
+ * passed region if outside.
+ *
+ * To unconfine the pointer, send the destroy request. This will also destroy
+ * the wp_confined_pointer object.
+ *
+ * If the compositor decides to unconfine the pointer the unconfined event is
+ * sent. The wp_confined_pointer object is at this point defunct and should
+ * be destroyed.
+ * @section page_iface_zwp_confined_pointer_v1_api API
+ * See @ref iface_zwp_confined_pointer_v1.
+ */
+/**
+ * @defgroup iface_zwp_confined_pointer_v1 The zwp_confined_pointer_v1 interface
+ *
+ * The wp_confined_pointer interface represents a confined pointer state.
+ *
+ * This object will send the event 'confined' when the confinement is
+ * activated. Whenever the confinement is activated, it is guaranteed that
+ * the surface the pointer is confined to will already have received pointer
+ * focus and that the pointer will be within the region passed to the request
+ * creating this object. It is up to the compositor to decide whether this
+ * requires some user interaction and if the pointer will warp to within the
+ * passed region if outside.
+ *
+ * To unconfine the pointer, send the destroy request. This will also destroy
+ * the wp_confined_pointer object.
+ *
+ * If the compositor decides to unconfine the pointer the unconfined event is
+ * sent. The wp_confined_pointer object is at this point defunct and should
+ * be destroyed.
+ */
+extern const struct wl_interface zwp_confined_pointer_v1_interface;
+#endif
+
+#ifndef ZWP_POINTER_CONSTRAINTS_V1_ERROR_ENUM
+#define ZWP_POINTER_CONSTRAINTS_V1_ERROR_ENUM
+/**
+ * @ingroup iface_zwp_pointer_constraints_v1
+ * wp_pointer_constraints error values
+ *
+ * These errors can be emitted in response to wp_pointer_constraints
+ * requests.
+ */
+enum zwp_pointer_constraints_v1_error {
+	/**
+	 * pointer constraint already requested on that surface
+	 */
+	ZWP_POINTER_CONSTRAINTS_V1_ERROR_ALREADY_CONSTRAINED = 1,
+};
+#endif /* ZWP_POINTER_CONSTRAINTS_V1_ERROR_ENUM */
+
+#ifndef ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ENUM
+#define ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ENUM
+/**
+ * @ingroup iface_zwp_pointer_constraints_v1
+ * constraint lifetime
+ *
+ * These values represent different lifetime semantics. They are passed
+ * as arguments to the factory requests to specify how the constraint
+ * lifetimes should be managed.
+ */
+enum zwp_pointer_constraints_v1_lifetime {
+	/**
+	 * the pointer constraint is defunct once deactivated
+	 *
+	 * A oneshot pointer constraint will never reactivate once it has
+	 * been deactivated. See the corresponding deactivation event
+	 * (wp_locked_pointer.unlocked and wp_confined_pointer.unconfined)
+	 * for details.
+	 */
+	ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ONESHOT = 1,
+	/**
+	 * the pointer constraint may reactivate
+	 *
+	 * A persistent pointer constraint may again reactivate once it
+	 * has been deactivated. See the corresponding deactivation event
+	 * (wp_locked_pointer.unlocked and wp_confined_pointer.unconfined)
+	 * for details.
+	 */
+	ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT = 2,
+};
+#endif /* ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_ENUM */
+
+#define ZWP_POINTER_CONSTRAINTS_V1_DESTROY 0
+#define ZWP_POINTER_CONSTRAINTS_V1_LOCK_POINTER 1
+#define ZWP_POINTER_CONSTRAINTS_V1_CONFINE_POINTER 2
+
+
+/**
+ * @ingroup iface_zwp_pointer_constraints_v1
+ */
+#define ZWP_POINTER_CONSTRAINTS_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_pointer_constraints_v1
+ */
+#define ZWP_POINTER_CONSTRAINTS_V1_LOCK_POINTER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_pointer_constraints_v1
+ */
+#define ZWP_POINTER_CONSTRAINTS_V1_CONFINE_POINTER_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_pointer_constraints_v1 */
+static inline void
+zwp_pointer_constraints_v1_set_user_data(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_pointer_constraints_v1, user_data);
+}
+
+/** @ingroup iface_zwp_pointer_constraints_v1 */
+static inline void *
+zwp_pointer_constraints_v1_get_user_data(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_pointer_constraints_v1);
+}
+
+static inline uint32_t
+zwp_pointer_constraints_v1_get_version(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_pointer_constraints_v1);
+}
+
+/**
+ * @ingroup iface_zwp_pointer_constraints_v1
+ *
+ * Used by the client to notify the server that it will no longer use this
+ * pointer constraints object.
+ */
+static inline void
+zwp_pointer_constraints_v1_destroy(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) zwp_pointer_constraints_v1,
+			 ZWP_POINTER_CONSTRAINTS_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_pointer_constraints_v1), WL_MARSHAL_FLAG_DESTROY);
+}
+
+/**
+ * @ingroup iface_zwp_pointer_constraints_v1
+ *
+ * The lock_pointer request lets the client request to disable movements of
+ * the virtual pointer (i.e. the cursor), effectively locking the pointer
+ * to a position. This request may not take effect immediately; in the
+ * future, when the compositor deems implementation-specific constraints
+ * are satisfied, the pointer lock will be activated and the compositor
+ * sends a locked event.
+ *
+ * The protocol provides no guarantee that the constraints are ever
+ * satisfied, and does not require the compositor to send an error if the
+ * constraints cannot ever be satisfied. It is thus possible to request a
+ * lock that will never activate.
+ *
+ * There may not be another pointer constraint of any kind requested or
+ * active on the surface for any of the wl_pointer objects of the seat of
+ * the passed pointer when requesting a lock. If there is, an error will be
+ * raised. See general pointer lock documentation for more details.
+ *
+ * The intersection of the region passed with this request and the input
+ * region of the surface is used to determine where the pointer must be
+ * in order for the lock to activate. It is up to the compositor whether to
+ * warp the pointer or require some kind of user interaction for the lock
+ * to activate. If the region is null the surface input region is used.
+ *
+ * A surface may receive pointer focus without the lock being activated.
+ *
+ * The request creates a new object wp_locked_pointer which is used to
+ * interact with the lock as well as receive updates about its state. See
+ * the the description of wp_locked_pointer for further information.
+ *
+ * Note that while a pointer is locked, the wl_pointer objects of the
+ * corresponding seat will not emit any wl_pointer.motion events, but
+ * relative motion events will still be emitted via wp_relative_pointer
+ * objects of the same seat. wl_pointer.axis and wl_pointer.button events
+ * are unaffected.
+ */
+static inline struct zwp_locked_pointer_v1 *
+zwp_pointer_constraints_v1_lock_pointer(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1, struct wl_surface *surface, struct wl_pointer *pointer, struct wl_region *region, uint32_t lifetime)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_flags((struct wl_proxy *) zwp_pointer_constraints_v1,
+			 ZWP_POINTER_CONSTRAINTS_V1_LOCK_POINTER, &zwp_locked_pointer_v1_interface, wl_proxy_get_version((struct wl_proxy *) zwp_pointer_constraints_v1), 0, NULL, surface, pointer, region, lifetime);
+
+	return (struct zwp_locked_pointer_v1 *) id;
+}
+
+/**
+ * @ingroup iface_zwp_pointer_constraints_v1
+ *
+ * The confine_pointer request lets the client request to confine the
+ * pointer cursor to a given region. This request may not take effect
+ * immediately; in the future, when the compositor deems implementation-
+ * specific constraints are satisfied, the pointer confinement will be
+ * activated and the compositor sends a confined event.
+ *
+ * The intersection of the region passed with this request and the input
+ * region of the surface is used to determine where the pointer must be
+ * in order for the confinement to activate. It is up to the compositor
+ * whether to warp the pointer or require some kind of user interaction for
+ * the confinement to activate. If the region is null the surface input
+ * region is used.
+ *
+ * The request will create a new object wp_confined_pointer which is used
+ * to interact with the confinement as well as receive updates about its
+ * state. See the the description of wp_confined_pointer for further
+ * information.
+ */
+static inline struct zwp_confined_pointer_v1 *
+zwp_pointer_constraints_v1_confine_pointer(struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1, struct wl_surface *surface, struct wl_pointer *pointer, struct wl_region *region, uint32_t lifetime)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_flags((struct wl_proxy *) zwp_pointer_constraints_v1,
+			 ZWP_POINTER_CONSTRAINTS_V1_CONFINE_POINTER, &zwp_confined_pointer_v1_interface, wl_proxy_get_version((struct wl_proxy *) zwp_pointer_constraints_v1), 0, NULL, surface, pointer, region, lifetime);
+
+	return (struct zwp_confined_pointer_v1 *) id;
+}
+
+/**
+ * @ingroup iface_zwp_locked_pointer_v1
+ * @struct zwp_locked_pointer_v1_listener
+ */
+struct zwp_locked_pointer_v1_listener {
+	/**
+	 * lock activation event
+	 *
+	 * Notification that the pointer lock of the seat's pointer is
+	 * activated.
+	 */
+	void (*locked)(void *data,
+		       struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1);
+	/**
+	 * lock deactivation event
+	 *
+	 * Notification that the pointer lock of the seat's pointer is no
+	 * longer active. If this is a oneshot pointer lock (see
+	 * wp_pointer_constraints.lifetime) this object is now defunct and
+	 * should be destroyed. If this is a persistent pointer lock (see
+	 * wp_pointer_constraints.lifetime) this pointer lock may again
+	 * reactivate in the future.
+	 */
+	void (*unlocked)(void *data,
+			 struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1);
+};
+
+/**
+ * @ingroup iface_zwp_locked_pointer_v1
+ */
+static inline int
+zwp_locked_pointer_v1_add_listener(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1,
+				   const struct zwp_locked_pointer_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_locked_pointer_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_LOCKED_POINTER_V1_DESTROY 0
+#define ZWP_LOCKED_POINTER_V1_SET_CURSOR_POSITION_HINT 1
+#define ZWP_LOCKED_POINTER_V1_SET_REGION 2
+
+/**
+ * @ingroup iface_zwp_locked_pointer_v1
+ */
+#define ZWP_LOCKED_POINTER_V1_LOCKED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_locked_pointer_v1
+ */
+#define ZWP_LOCKED_POINTER_V1_UNLOCKED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_locked_pointer_v1
+ */
+#define ZWP_LOCKED_POINTER_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_locked_pointer_v1
+ */
+#define ZWP_LOCKED_POINTER_V1_SET_CURSOR_POSITION_HINT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_locked_pointer_v1
+ */
+#define ZWP_LOCKED_POINTER_V1_SET_REGION_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_locked_pointer_v1 */
+static inline void
+zwp_locked_pointer_v1_set_user_data(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_locked_pointer_v1, user_data);
+}
+
+/** @ingroup iface_zwp_locked_pointer_v1 */
+static inline void *
+zwp_locked_pointer_v1_get_user_data(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_locked_pointer_v1);
+}
+
+static inline uint32_t
+zwp_locked_pointer_v1_get_version(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_locked_pointer_v1);
+}
+
+/**
+ * @ingroup iface_zwp_locked_pointer_v1
+ *
+ * Destroy the locked pointer object. If applicable, the compositor will
+ * unlock the pointer.
+ */
+static inline void
+zwp_locked_pointer_v1_destroy(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) zwp_locked_pointer_v1,
+			 ZWP_LOCKED_POINTER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_locked_pointer_v1), WL_MARSHAL_FLAG_DESTROY);
+}
+
+/**
+ * @ingroup iface_zwp_locked_pointer_v1
+ *
+ * Set the cursor position hint relative to the top left corner of the
+ * surface.
+ *
+ * If the client is drawing its own cursor, it should update the position
+ * hint to the position of its own cursor. A compositor may use this
+ * information to warp the pointer upon unlock in order to avoid pointer
+ * jumps.
+ *
+ * The cursor position hint is double buffered. The new hint will only take
+ * effect when the associated surface gets it pending state applied. See
+ * wl_surface.commit for details.
+ */
+static inline void
+zwp_locked_pointer_v1_set_cursor_position_hint(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1, wl_fixed_t surface_x, wl_fixed_t surface_y)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) zwp_locked_pointer_v1,
+			 ZWP_LOCKED_POINTER_V1_SET_CURSOR_POSITION_HINT, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_locked_pointer_v1), 0, surface_x, surface_y);
+}
+
+/**
+ * @ingroup iface_zwp_locked_pointer_v1
+ *
+ * Set a new region used to lock the pointer.
+ *
+ * The new lock region is double-buffered. The new lock region will
+ * only take effect when the associated surface gets its pending state
+ * applied. See wl_surface.commit for details.
+ *
+ * For details about the lock region, see wp_locked_pointer.
+ */
+static inline void
+zwp_locked_pointer_v1_set_region(struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1, struct wl_region *region)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) zwp_locked_pointer_v1,
+			 ZWP_LOCKED_POINTER_V1_SET_REGION, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_locked_pointer_v1), 0, region);
+}
+
+/**
+ * @ingroup iface_zwp_confined_pointer_v1
+ * @struct zwp_confined_pointer_v1_listener
+ */
+struct zwp_confined_pointer_v1_listener {
+	/**
+	 * pointer confined
+	 *
+	 * Notification that the pointer confinement of the seat's
+	 * pointer is activated.
+	 */
+	void (*confined)(void *data,
+			 struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1);
+	/**
+	 * pointer unconfined
+	 *
+	 * Notification that the pointer confinement of the seat's
+	 * pointer is no longer active. If this is a oneshot pointer
+	 * confinement (see wp_pointer_constraints.lifetime) this object is
+	 * now defunct and should be destroyed. If this is a persistent
+	 * pointer confinement (see wp_pointer_constraints.lifetime) this
+	 * pointer confinement may again reactivate in the future.
+	 */
+	void (*unconfined)(void *data,
+			   struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1);
+};
+
+/**
+ * @ingroup iface_zwp_confined_pointer_v1
+ */
+static inline int
+zwp_confined_pointer_v1_add_listener(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1,
+				     const struct zwp_confined_pointer_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_confined_pointer_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_CONFINED_POINTER_V1_DESTROY 0
+#define ZWP_CONFINED_POINTER_V1_SET_REGION 1
+
+/**
+ * @ingroup iface_zwp_confined_pointer_v1
+ */
+#define ZWP_CONFINED_POINTER_V1_CONFINED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_confined_pointer_v1
+ */
+#define ZWP_CONFINED_POINTER_V1_UNCONFINED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_confined_pointer_v1
+ */
+#define ZWP_CONFINED_POINTER_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_confined_pointer_v1
+ */
+#define ZWP_CONFINED_POINTER_V1_SET_REGION_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_confined_pointer_v1 */
+static inline void
+zwp_confined_pointer_v1_set_user_data(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_confined_pointer_v1, user_data);
+}
+
+/** @ingroup iface_zwp_confined_pointer_v1 */
+static inline void *
+zwp_confined_pointer_v1_get_user_data(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_confined_pointer_v1);
+}
+
+static inline uint32_t
+zwp_confined_pointer_v1_get_version(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_confined_pointer_v1);
+}
+
+/**
+ * @ingroup iface_zwp_confined_pointer_v1
+ *
+ * Destroy the confined pointer object. If applicable, the compositor will
+ * unconfine the pointer.
+ */
+static inline void
+zwp_confined_pointer_v1_destroy(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) zwp_confined_pointer_v1,
+			 ZWP_CONFINED_POINTER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_confined_pointer_v1), WL_MARSHAL_FLAG_DESTROY);
+}
+
+/**
+ * @ingroup iface_zwp_confined_pointer_v1
+ *
+ * Set a new region used to confine the pointer.
+ *
+ * The new confine region is double-buffered. The new confine region will
+ * only take effect when the associated surface gets its pending state
+ * applied. See wl_surface.commit for details.
+ *
+ * If the confinement is active when the new confinement region is applied
+ * and the pointer ends up outside of newly applied region, the pointer may
+ * warped to a position within the new confinement region. If warped, a
+ * wl_pointer.motion event will be emitted, but no
+ * wp_relative_pointer.relative_motion event.
+ *
+ * The compositor may also, instead of using the new region, unconfine the
+ * pointer.
+ *
+ * For details about the confine region, see wp_confined_pointer.
+ */
+static inline void
+zwp_confined_pointer_v1_set_region(struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1, struct wl_region *region)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) zwp_confined_pointer_v1,
+			 ZWP_CONFINED_POINTER_V1_SET_REGION, NULL, wl_proxy_get_version((struct wl_proxy *) zwp_confined_pointer_v1), 0, region);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/cmd/devdraw/wayland-xdg-decoration.c b/src/cmd/devdraw/wayland-xdg-decoration.c
new file mode 100644
index 00000000..5237ce0f
--- /dev/null
+++ b/src/cmd/devdraw/wayland-xdg-decoration.c
@@ -0,0 +1,66 @@
+/* Generated by wayland-scanner 1.23.0 */
+
+/*
+ * Copyright © 2018 Simon Ser
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface xdg_toplevel_interface;
+extern const struct wl_interface zxdg_toplevel_decoration_v1_interface;
+
+static const struct wl_interface *xdg_decoration_unstable_v1_types[] = {
+	NULL,
+	&zxdg_toplevel_decoration_v1_interface,
+	&xdg_toplevel_interface,
+};
+
+static const struct wl_message zxdg_decoration_manager_v1_requests[] = {
+	{ "destroy", "", xdg_decoration_unstable_v1_types + 0 },
+	{ "get_toplevel_decoration", "no", xdg_decoration_unstable_v1_types + 1 },
+};
+
+WL_EXPORT const struct wl_interface zxdg_decoration_manager_v1_interface = {
+	"zxdg_decoration_manager_v1", 1,
+	2, zxdg_decoration_manager_v1_requests,
+	0, NULL,
+};
+
+static const struct wl_message zxdg_toplevel_decoration_v1_requests[] = {
+	{ "destroy", "", xdg_decoration_unstable_v1_types + 0 },
+	{ "set_mode", "u", xdg_decoration_unstable_v1_types + 0 },
+	{ "unset_mode", "", xdg_decoration_unstable_v1_types + 0 },
+};
+
+static const struct wl_message zxdg_toplevel_decoration_v1_events[] = {
+	{ "configure", "u", xdg_decoration_unstable_v1_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zxdg_toplevel_decoration_v1_interface = {
+	"zxdg_toplevel_decoration_v1", 1,
+	3, zxdg_toplevel_decoration_v1_requests,
+	1, zxdg_toplevel_decoration_v1_events,
+};
+
diff --git a/src/cmd/devdraw/wayland-xdg-decoration.h b/src/cmd/devdraw/wayland-xdg-decoration.h
new file mode 100644
index 00000000..c7426350
--- /dev/null
+++ b/src/cmd/devdraw/wayland-xdg-decoration.h
@@ -0,0 +1,377 @@
+/* Generated by wayland-scanner 1.23.0 */
+
+#ifndef XDG_DECORATION_UNSTABLE_V1_CLIENT_PROTOCOL_H
+#define XDG_DECORATION_UNSTABLE_V1_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_xdg_decoration_unstable_v1 The xdg_decoration_unstable_v1 protocol
+ * @section page_ifaces_xdg_decoration_unstable_v1 Interfaces
+ * - @subpage page_iface_zxdg_decoration_manager_v1 - window decoration manager
+ * - @subpage page_iface_zxdg_toplevel_decoration_v1 - decoration object for a toplevel surface
+ * @section page_copyright_xdg_decoration_unstable_v1 Copyright
+ * <pre>
+ *
+ * Copyright © 2018 Simon Ser
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct xdg_toplevel;
+struct zxdg_decoration_manager_v1;
+struct zxdg_toplevel_decoration_v1;
+
+#ifndef ZXDG_DECORATION_MANAGER_V1_INTERFACE
+#define ZXDG_DECORATION_MANAGER_V1_INTERFACE
+/**
+ * @page page_iface_zxdg_decoration_manager_v1 zxdg_decoration_manager_v1
+ * @section page_iface_zxdg_decoration_manager_v1_desc Description
+ *
+ * This interface allows a compositor to announce support for server-side
+ * decorations.
+ *
+ * A window decoration is a set of window controls as deemed appropriate by
+ * the party managing them, such as user interface components used to move,
+ * resize and change a window's state.
+ *
+ * A client can use this protocol to request being decorated by a supporting
+ * compositor.
+ *
+ * If compositor and client do not negotiate the use of a server-side
+ * decoration using this protocol, clients continue to self-decorate as they
+ * see fit.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ * @section page_iface_zxdg_decoration_manager_v1_api API
+ * See @ref iface_zxdg_decoration_manager_v1.
+ */
+/**
+ * @defgroup iface_zxdg_decoration_manager_v1 The zxdg_decoration_manager_v1 interface
+ *
+ * This interface allows a compositor to announce support for server-side
+ * decorations.
+ *
+ * A window decoration is a set of window controls as deemed appropriate by
+ * the party managing them, such as user interface components used to move,
+ * resize and change a window's state.
+ *
+ * A client can use this protocol to request being decorated by a supporting
+ * compositor.
+ *
+ * If compositor and client do not negotiate the use of a server-side
+ * decoration using this protocol, clients continue to self-decorate as they
+ * see fit.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ */
+extern const struct wl_interface zxdg_decoration_manager_v1_interface;
+#endif
+#ifndef ZXDG_TOPLEVEL_DECORATION_V1_INTERFACE
+#define ZXDG_TOPLEVEL_DECORATION_V1_INTERFACE
+/**
+ * @page page_iface_zxdg_toplevel_decoration_v1 zxdg_toplevel_decoration_v1
+ * @section page_iface_zxdg_toplevel_decoration_v1_desc Description
+ *
+ * The decoration object allows the compositor to toggle server-side window
+ * decorations for a toplevel surface. The client can request to switch to
+ * another mode.
+ *
+ * The xdg_toplevel_decoration object must be destroyed before its
+ * xdg_toplevel.
+ * @section page_iface_zxdg_toplevel_decoration_v1_api API
+ * See @ref iface_zxdg_toplevel_decoration_v1.
+ */
+/**
+ * @defgroup iface_zxdg_toplevel_decoration_v1 The zxdg_toplevel_decoration_v1 interface
+ *
+ * The decoration object allows the compositor to toggle server-side window
+ * decorations for a toplevel surface. The client can request to switch to
+ * another mode.
+ *
+ * The xdg_toplevel_decoration object must be destroyed before its
+ * xdg_toplevel.
+ */
+extern const struct wl_interface zxdg_toplevel_decoration_v1_interface;
+#endif
+
+#define ZXDG_DECORATION_MANAGER_V1_DESTROY 0
+#define ZXDG_DECORATION_MANAGER_V1_GET_TOPLEVEL_DECORATION 1
+
+
+/**
+ * @ingroup iface_zxdg_decoration_manager_v1
+ */
+#define ZXDG_DECORATION_MANAGER_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_decoration_manager_v1
+ */
+#define ZXDG_DECORATION_MANAGER_V1_GET_TOPLEVEL_DECORATION_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_decoration_manager_v1 */
+static inline void
+zxdg_decoration_manager_v1_set_user_data(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_decoration_manager_v1, user_data);
+}
+
+/** @ingroup iface_zxdg_decoration_manager_v1 */
+static inline void *
+zxdg_decoration_manager_v1_get_user_data(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_decoration_manager_v1);
+}
+
+static inline uint32_t
+zxdg_decoration_manager_v1_get_version(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_decoration_manager_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_decoration_manager_v1
+ *
+ * Destroy the decoration manager. This doesn't destroy objects created
+ * with the manager.
+ */
+static inline void
+zxdg_decoration_manager_v1_destroy(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_decoration_manager_v1,
+			 ZXDG_DECORATION_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_decoration_manager_v1), WL_MARSHAL_FLAG_DESTROY);
+}
+
+/**
+ * @ingroup iface_zxdg_decoration_manager_v1
+ *
+ * Create a new decoration object associated with the given toplevel.
+ *
+ * Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
+ * buffer attached or committed is a client error, and any attempts by a
+ * client to attach or manipulate a buffer prior to the first
+ * xdg_toplevel_decoration.configure event must also be treated as
+ * errors.
+ */
+static inline struct zxdg_toplevel_decoration_v1 *
+zxdg_decoration_manager_v1_get_toplevel_decoration(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1, struct xdg_toplevel *toplevel)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_flags((struct wl_proxy *) zxdg_decoration_manager_v1,
+			 ZXDG_DECORATION_MANAGER_V1_GET_TOPLEVEL_DECORATION, &zxdg_toplevel_decoration_v1_interface, wl_proxy_get_version((struct wl_proxy *) zxdg_decoration_manager_v1), 0, NULL, toplevel);
+
+	return (struct zxdg_toplevel_decoration_v1 *) id;
+}
+
+#ifndef ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ENUM
+#define ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ENUM
+enum zxdg_toplevel_decoration_v1_error {
+	/**
+	 * xdg_toplevel has a buffer attached before configure
+	 */
+	ZXDG_TOPLEVEL_DECORATION_V1_ERROR_UNCONFIGURED_BUFFER = 0,
+	/**
+	 * xdg_toplevel already has a decoration object
+	 */
+	ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ALREADY_CONSTRUCTED = 1,
+	/**
+	 * xdg_toplevel destroyed before the decoration object
+	 */
+	ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ORPHANED = 2,
+};
+#endif /* ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ENUM */
+
+#ifndef ZXDG_TOPLEVEL_DECORATION_V1_MODE_ENUM
+#define ZXDG_TOPLEVEL_DECORATION_V1_MODE_ENUM
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ * window decoration modes
+ *
+ * These values describe window decoration modes.
+ */
+enum zxdg_toplevel_decoration_v1_mode {
+	/**
+	 * no server-side window decoration
+	 */
+	ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE = 1,
+	/**
+	 * server-side window decoration
+	 */
+	ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE = 2,
+};
+#endif /* ZXDG_TOPLEVEL_DECORATION_V1_MODE_ENUM */
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ * @struct zxdg_toplevel_decoration_v1_listener
+ */
+struct zxdg_toplevel_decoration_v1_listener {
+	/**
+	 * notify a decoration mode change
+	 *
+	 * The configure event configures the effective decoration mode.
+	 * The configured state should not be applied immediately. Clients
+	 * must send an ack_configure in response to this event. See
+	 * xdg_surface.configure and xdg_surface.ack_configure for details.
+	 *
+	 * A configure event can be sent at any time. The specified mode
+	 * must be obeyed by the client.
+	 * @param mode the decoration mode
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1,
+			  uint32_t mode);
+};
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ */
+static inline int
+zxdg_toplevel_decoration_v1_add_listener(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1,
+					 const struct zxdg_toplevel_decoration_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_toplevel_decoration_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_TOPLEVEL_DECORATION_V1_DESTROY 0
+#define ZXDG_TOPLEVEL_DECORATION_V1_SET_MODE 1
+#define ZXDG_TOPLEVEL_DECORATION_V1_UNSET_MODE 2
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ */
+#define ZXDG_TOPLEVEL_DECORATION_V1_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ */
+#define ZXDG_TOPLEVEL_DECORATION_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ */
+#define ZXDG_TOPLEVEL_DECORATION_V1_SET_MODE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ */
+#define ZXDG_TOPLEVEL_DECORATION_V1_UNSET_MODE_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_toplevel_decoration_v1 */
+static inline void
+zxdg_toplevel_decoration_v1_set_user_data(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_toplevel_decoration_v1, user_data);
+}
+
+/** @ingroup iface_zxdg_toplevel_decoration_v1 */
+static inline void *
+zxdg_toplevel_decoration_v1_get_user_data(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_toplevel_decoration_v1);
+}
+
+static inline uint32_t
+zxdg_toplevel_decoration_v1_get_version(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_decoration_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ *
+ * Switch back to a mode without any server-side decorations at the next
+ * commit.
+ */
+static inline void
+zxdg_toplevel_decoration_v1_destroy(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_toplevel_decoration_v1,
+			 ZXDG_TOPLEVEL_DECORATION_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_decoration_v1), WL_MARSHAL_FLAG_DESTROY);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ *
+ * Set the toplevel surface decoration mode. This informs the compositor
+ * that the client prefers the provided decoration mode.
+ *
+ * After requesting a decoration mode, the compositor will respond by
+ * emitting an xdg_surface.configure event. The client should then update
+ * its content, drawing it without decorations if the received mode is
+ * server-side decorations. The client must also acknowledge the configure
+ * when committing the new content (see xdg_surface.ack_configure).
+ *
+ * The compositor can decide not to use the client's mode and enforce a
+ * different mode instead.
+ *
+ * Clients whose decoration mode depend on the xdg_toplevel state may send
+ * a set_mode request in response to an xdg_surface.configure event and wait
+ * for the next xdg_surface.configure event to prevent unwanted state.
+ * Such clients are responsible for preventing configure loops and must
+ * make sure not to send multiple successive set_mode requests with the
+ * same decoration mode.
+ */
+static inline void
+zxdg_toplevel_decoration_v1_set_mode(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1, uint32_t mode)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_toplevel_decoration_v1,
+			 ZXDG_TOPLEVEL_DECORATION_V1_SET_MODE, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_decoration_v1), 0, mode);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ *
+ * Unset the toplevel surface decoration mode. This informs the compositor
+ * that the client doesn't prefer a particular decoration mode.
+ *
+ * This request has the same semantics as set_mode.
+ */
+static inline void
+zxdg_toplevel_decoration_v1_unset_mode(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_toplevel_decoration_v1,
+			 ZXDG_TOPLEVEL_DECORATION_V1_UNSET_MODE, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_decoration_v1), 0);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/cmd/devdraw/wayland-xdg-shell.c b/src/cmd/devdraw/wayland-xdg-shell.c
new file mode 100644
index 00000000..550a2360
--- /dev/null
+++ b/src/cmd/devdraw/wayland-xdg-shell.c
@@ -0,0 +1,174 @@
+/* Generated by wayland-scanner 1.23.0 */
+
+/*
+ * Copyright © 2008-2013 Kristian Høgsberg
+ * Copyright © 2013      Rafael Antognolli
+ * Copyright © 2013      Jasper St. Pierre
+ * Copyright © 2010-2013 Intel Corporation
+ * Copyright © 2015-2017 Samsung Electronics Co., Ltd
+ * Copyright © 2015-2017 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_output_interface;
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface xdg_popup_interface;
+extern const struct wl_interface xdg_positioner_interface;
+extern const struct wl_interface xdg_surface_interface;
+extern const struct wl_interface xdg_toplevel_interface;
+
+static const struct wl_interface *xdg_shell_types[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&xdg_positioner_interface,
+	&xdg_surface_interface,
+	&wl_surface_interface,
+	&xdg_toplevel_interface,
+	&xdg_popup_interface,
+	&xdg_surface_interface,
+	&xdg_positioner_interface,
+	&xdg_toplevel_interface,
+	&wl_seat_interface,
+	NULL,
+	NULL,
+	NULL,
+	&wl_seat_interface,
+	NULL,
+	&wl_seat_interface,
+	NULL,
+	NULL,
+	&wl_output_interface,
+	&wl_seat_interface,
+	NULL,
+	&xdg_positioner_interface,
+	NULL,
+};
+
+static const struct wl_message xdg_wm_base_requests[] = {
+	{ "destroy", "", xdg_shell_types + 0 },
+	{ "create_positioner", "n", xdg_shell_types + 4 },
+	{ "get_xdg_surface", "no", xdg_shell_types + 5 },
+	{ "pong", "u", xdg_shell_types + 0 },
+};
+
+static const struct wl_message xdg_wm_base_events[] = {
+	{ "ping", "u", xdg_shell_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_wm_base_interface = {
+	"xdg_wm_base", 6,
+	4, xdg_wm_base_requests,
+	1, xdg_wm_base_events,
+};
+
+static const struct wl_message xdg_positioner_requests[] = {
+	{ "destroy", "", xdg_shell_types + 0 },
+	{ "set_size", "ii", xdg_shell_types + 0 },
+	{ "set_anchor_rect", "iiii", xdg_shell_types + 0 },
+	{ "set_anchor", "u", xdg_shell_types + 0 },
+	{ "set_gravity", "u", xdg_shell_types + 0 },
+	{ "set_constraint_adjustment", "u", xdg_shell_types + 0 },
+	{ "set_offset", "ii", xdg_shell_types + 0 },
+	{ "set_reactive", "3", xdg_shell_types + 0 },
+	{ "set_parent_size", "3ii", xdg_shell_types + 0 },
+	{ "set_parent_configure", "3u", xdg_shell_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_positioner_interface = {
+	"xdg_positioner", 6,
+	10, xdg_positioner_requests,
+	0, NULL,
+};
+
+static const struct wl_message xdg_surface_requests[] = {
+	{ "destroy", "", xdg_shell_types + 0 },
+	{ "get_toplevel", "n", xdg_shell_types + 7 },
+	{ "get_popup", "n?oo", xdg_shell_types + 8 },
+	{ "set_window_geometry", "iiii", xdg_shell_types + 0 },
+	{ "ack_configure", "u", xdg_shell_types + 0 },
+};
+
+static const struct wl_message xdg_surface_events[] = {
+	{ "configure", "u", xdg_shell_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_surface_interface = {
+	"xdg_surface", 6,
+	5, xdg_surface_requests,
+	1, xdg_surface_events,
+};
+
+static const struct wl_message xdg_toplevel_requests[] = {
+	{ "destroy", "", xdg_shell_types + 0 },
+	{ "set_parent", "?o", xdg_shell_types + 11 },
+	{ "set_title", "s", xdg_shell_types + 0 },
+	{ "set_app_id", "s", xdg_shell_types + 0 },
+	{ "show_window_menu", "ouii", xdg_shell_types + 12 },
+	{ "move", "ou", xdg_shell_types + 16 },
+	{ "resize", "ouu", xdg_shell_types + 18 },
+	{ "set_max_size", "ii", xdg_shell_types + 0 },
+	{ "set_min_size", "ii", xdg_shell_types + 0 },
+	{ "set_maximized", "", xdg_shell_types + 0 },
+	{ "unset_maximized", "", xdg_shell_types + 0 },
+	{ "set_fullscreen", "?o", xdg_shell_types + 21 },
+	{ "unset_fullscreen", "", xdg_shell_types + 0 },
+	{ "set_minimized", "", xdg_shell_types + 0 },
+};
+
+static const struct wl_message xdg_toplevel_events[] = {
+	{ "configure", "iia", xdg_shell_types + 0 },
+	{ "close", "", xdg_shell_types + 0 },
+	{ "configure_bounds", "4ii", xdg_shell_types + 0 },
+	{ "wm_capabilities", "5a", xdg_shell_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_toplevel_interface = {
+	"xdg_toplevel", 6,
+	14, xdg_toplevel_requests,
+	4, xdg_toplevel_events,
+};
+
+static const struct wl_message xdg_popup_requests[] = {
+	{ "destroy", "", xdg_shell_types + 0 },
+	{ "grab", "ou", xdg_shell_types + 22 },
+	{ "reposition", "3ou", xdg_shell_types + 24 },
+};
+
+static const struct wl_message xdg_popup_events[] = {
+	{ "configure", "iiii", xdg_shell_types + 0 },
+	{ "popup_done", "", xdg_shell_types + 0 },
+	{ "repositioned", "3u", xdg_shell_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_popup_interface = {
+	"xdg_popup", 6,
+	3, xdg_popup_requests,
+	3, xdg_popup_events,
+};
+
diff --git a/src/cmd/devdraw/wayland-xdg-shell.h b/src/cmd/devdraw/wayland-xdg-shell.h
new file mode 100644
index 00000000..c8c4cdd8
--- /dev/null
+++ b/src/cmd/devdraw/wayland-xdg-shell.h
@@ -0,0 +1,2327 @@
+/* Generated by wayland-scanner 1.23.0 */
+
+#ifndef XDG_SHELL_CLIENT_PROTOCOL_H
+#define XDG_SHELL_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "wayland-client.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_xdg_shell The xdg_shell protocol
+ * @section page_ifaces_xdg_shell Interfaces
+ * - @subpage page_iface_xdg_wm_base - create desktop-style surfaces
+ * - @subpage page_iface_xdg_positioner - child surface positioner
+ * - @subpage page_iface_xdg_surface - desktop user interface surface base interface
+ * - @subpage page_iface_xdg_toplevel - toplevel surface
+ * - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus
+ * @section page_copyright_xdg_shell Copyright
+ * <pre>
+ *
+ * Copyright © 2008-2013 Kristian Høgsberg
+ * Copyright © 2013      Rafael Antognolli
+ * Copyright © 2013      Jasper St. Pierre
+ * Copyright © 2010-2013 Intel Corporation
+ * Copyright © 2015-2017 Samsung Electronics Co., Ltd
+ * Copyright © 2015-2017 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_output;
+struct wl_seat;
+struct wl_surface;
+struct xdg_popup;
+struct xdg_positioner;
+struct xdg_surface;
+struct xdg_toplevel;
+struct xdg_wm_base;
+
+#ifndef XDG_WM_BASE_INTERFACE
+#define XDG_WM_BASE_INTERFACE
+/**
+ * @page page_iface_xdg_wm_base xdg_wm_base
+ * @section page_iface_xdg_wm_base_desc Description
+ *
+ * The xdg_wm_base interface is exposed as a global object enabling clients
+ * to turn their wl_surfaces into windows in a desktop environment. It
+ * defines the basic functionality needed for clients and the compositor to
+ * create windows that can be dragged, resized, maximized, etc, as well as
+ * creating transient windows such as popup menus.
+ * @section page_iface_xdg_wm_base_api API
+ * See @ref iface_xdg_wm_base.
+ */
+/**
+ * @defgroup iface_xdg_wm_base The xdg_wm_base interface
+ *
+ * The xdg_wm_base interface is exposed as a global object enabling clients
+ * to turn their wl_surfaces into windows in a desktop environment. It
+ * defines the basic functionality needed for clients and the compositor to
+ * create windows that can be dragged, resized, maximized, etc, as well as
+ * creating transient windows such as popup menus.
+ */
+extern const struct wl_interface xdg_wm_base_interface;
+#endif
+#ifndef XDG_POSITIONER_INTERFACE
+#define XDG_POSITIONER_INTERFACE
+/**
+ * @page page_iface_xdg_positioner xdg_positioner
+ * @section page_iface_xdg_positioner_desc Description
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle. These positioner-created rules are
+ * constrained by the requirement that a child surface must intersect with or
+ * be at least partially adjacent to its parent surface.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an invalid_positioner error.
+ * @section page_iface_xdg_positioner_api API
+ * See @ref iface_xdg_positioner.
+ */
+/**
+ * @defgroup iface_xdg_positioner The xdg_positioner interface
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle. These positioner-created rules are
+ * constrained by the requirement that a child surface must intersect with or
+ * be at least partially adjacent to its parent surface.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an invalid_positioner error.
+ */
+extern const struct wl_interface xdg_positioner_interface;
+#endif
+#ifndef XDG_SURFACE_INTERFACE
+#define XDG_SURFACE_INTERFACE
+/**
+ * @page page_iface_xdg_surface xdg_surface
+ * @section page_iface_xdg_surface_desc Description
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * After creating a role-specific object and setting it up, the client must
+ * perform an initial commit without any buffer attached. The compositor
+ * will reply with initial wl_surface state such as
+ * wl_surface.preferred_buffer_scale followed by an xdg_surface.configure
+ * event. The client must acknowledge it and is then allowed to attach a
+ * buffer to map the surface.
+ *
+ * Mapping an xdg_surface-based role surface is defined as making it
+ * possible for the surface to be shown by the compositor. Note that
+ * a mapped surface is not guaranteed to be visible once it is mapped.
+ *
+ * For an xdg_surface to be mapped by the compositor, the following
+ * conditions must be met:
+ * (1) the client has assigned an xdg_surface-based role to the surface
+ * (2) the client has set and committed the xdg_surface state and the
+ * role-dependent state to the surface
+ * (3) the client has committed a buffer to the surface
+ *
+ * A newly-unmapped surface is considered to have met condition (1) out
+ * of the 3 required conditions for mapping a surface if its role surface
+ * has not been destroyed, i.e. the client must perform the initial commit
+ * again before attaching a buffer.
+ * @section page_iface_xdg_surface_api API
+ * See @ref iface_xdg_surface.
+ */
+/**
+ * @defgroup iface_xdg_surface The xdg_surface interface
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * After creating a role-specific object and setting it up, the client must
+ * perform an initial commit without any buffer attached. The compositor
+ * will reply with initial wl_surface state such as
+ * wl_surface.preferred_buffer_scale followed by an xdg_surface.configure
+ * event. The client must acknowledge it and is then allowed to attach a
+ * buffer to map the surface.
+ *
+ * Mapping an xdg_surface-based role surface is defined as making it
+ * possible for the surface to be shown by the compositor. Note that
+ * a mapped surface is not guaranteed to be visible once it is mapped.
+ *
+ * For an xdg_surface to be mapped by the compositor, the following
+ * conditions must be met:
+ * (1) the client has assigned an xdg_surface-based role to the surface
+ * (2) the client has set and committed the xdg_surface state and the
+ * role-dependent state to the surface
+ * (3) the client has committed a buffer to the surface
+ *
+ * A newly-unmapped surface is considered to have met condition (1) out
+ * of the 3 required conditions for mapping a surface if its role surface
+ * has not been destroyed, i.e. the client must perform the initial commit
+ * again before attaching a buffer.
+ */
+extern const struct wl_interface xdg_surface_interface;
+#endif
+#ifndef XDG_TOPLEVEL_INTERFACE
+#define XDG_TOPLEVEL_INTERFACE
+/**
+ * @page page_iface_xdg_toplevel xdg_toplevel
+ * @section page_iface_xdg_toplevel_desc Description
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ *
+ * A xdg_toplevel by default is responsible for providing the full intended
+ * visual representation of the toplevel, which depending on the window
+ * state, may mean things like a title bar, window controls and drop shadow.
+ *
+ * Unmapping an xdg_toplevel means that the surface cannot be shown
+ * by the compositor until it is explicitly mapped again.
+ * All active operations (e.g., move, resize) are canceled and all
+ * attributes (e.g. title, state, stacking, ...) are discarded for
+ * an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
+ * the state it had right after xdg_surface.get_toplevel. The client
+ * can re-map the toplevel by perfoming a commit without any buffer
+ * attached, waiting for a configure event and handling it as usual (see
+ * xdg_surface description).
+ *
+ * Attaching a null buffer to a toplevel unmaps the surface.
+ * @section page_iface_xdg_toplevel_api API
+ * See @ref iface_xdg_toplevel.
+ */
+/**
+ * @defgroup iface_xdg_toplevel The xdg_toplevel interface
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ *
+ * A xdg_toplevel by default is responsible for providing the full intended
+ * visual representation of the toplevel, which depending on the window
+ * state, may mean things like a title bar, window controls and drop shadow.
+ *
+ * Unmapping an xdg_toplevel means that the surface cannot be shown
+ * by the compositor until it is explicitly mapped again.
+ * All active operations (e.g., move, resize) are canceled and all
+ * attributes (e.g. title, state, stacking, ...) are discarded for
+ * an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
+ * the state it had right after xdg_surface.get_toplevel. The client
+ * can re-map the toplevel by perfoming a commit without any buffer
+ * attached, waiting for a configure event and handling it as usual (see
+ * xdg_surface description).
+ *
+ * Attaching a null buffer to a toplevel unmaps the surface.
+ */
+extern const struct wl_interface xdg_toplevel_interface;
+#endif
+#ifndef XDG_POPUP_INTERFACE
+#define XDG_POPUP_INTERFACE
+/**
+ * @page page_iface_xdg_popup xdg_popup
+ * @section page_iface_xdg_popup_desc Description
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ * @section page_iface_xdg_popup_api API
+ * See @ref iface_xdg_popup.
+ */
+/**
+ * @defgroup iface_xdg_popup The xdg_popup interface
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ */
+extern const struct wl_interface xdg_popup_interface;
+#endif
+
+#ifndef XDG_WM_BASE_ERROR_ENUM
+#define XDG_WM_BASE_ERROR_ENUM
+enum xdg_wm_base_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	XDG_WM_BASE_ERROR_ROLE = 0,
+	/**
+	 * xdg_wm_base was destroyed before children
+	 */
+	XDG_WM_BASE_ERROR_DEFUNCT_SURFACES = 1,
+	/**
+	 * the client tried to map or destroy a non-topmost popup
+	 */
+	XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP = 2,
+	/**
+	 * the client specified an invalid popup parent surface
+	 */
+	XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT = 3,
+	/**
+	 * the client provided an invalid surface state
+	 */
+	XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE = 4,
+	/**
+	 * the client provided an invalid positioner
+	 */
+	XDG_WM_BASE_ERROR_INVALID_POSITIONER = 5,
+	/**
+	 * the client didn’t respond to a ping event in time
+	 */
+	XDG_WM_BASE_ERROR_UNRESPONSIVE = 6,
+};
+#endif /* XDG_WM_BASE_ERROR_ENUM */
+
+/**
+ * @ingroup iface_xdg_wm_base
+ * @struct xdg_wm_base_listener
+ */
+struct xdg_wm_base_listener {
+	/**
+	 * check if the client is alive
+	 *
+	 * The ping event asks the client if it's still alive. Pass the
+	 * serial specified in the event back to the compositor by sending
+	 * a "pong" request back with the specified serial. See
+	 * xdg_wm_base.pong.
+	 *
+	 * Compositors can use this to determine if the client is still
+	 * alive. It's unspecified what will happen if the client doesn't
+	 * respond to the ping request, or in what timeframe. Clients
+	 * should try to respond in a reasonable amount of time. The
+	 * “unresponsive” error is provided for compositors that wish
+	 * to disconnect unresponsive clients.
+	 *
+	 * A compositor is free to ping in any way it wants, but a client
+	 * must always respond to any xdg_wm_base object it created.
+	 * @param serial pass this to the pong request
+	 */
+	void (*ping)(void *data,
+		     struct xdg_wm_base *xdg_wm_base,
+		     uint32_t serial);
+};
+
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+static inline int
+xdg_wm_base_add_listener(struct xdg_wm_base *xdg_wm_base,
+			 const struct xdg_wm_base_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) xdg_wm_base,
+				     (void (**)(void)) listener, data);
+}
+
+#define XDG_WM_BASE_DESTROY 0
+#define XDG_WM_BASE_CREATE_POSITIONER 1
+#define XDG_WM_BASE_GET_XDG_SURFACE 2
+#define XDG_WM_BASE_PONG 3
+
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_PING_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_CREATE_POSITIONER_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_GET_XDG_SURFACE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_PONG_SINCE_VERSION 1
+
+/** @ingroup iface_xdg_wm_base */
+static inline void
+xdg_wm_base_set_user_data(struct xdg_wm_base *xdg_wm_base, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_wm_base, user_data);
+}
+
+/** @ingroup iface_xdg_wm_base */
+static inline void *
+xdg_wm_base_get_user_data(struct xdg_wm_base *xdg_wm_base)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_wm_base);
+}
+
+static inline uint32_t
+xdg_wm_base_get_version(struct xdg_wm_base *xdg_wm_base)
+{
+	return wl_proxy_get_version((struct wl_proxy *) xdg_wm_base);
+}
+
+/**
+ * @ingroup iface_xdg_wm_base
+ *
+ * Destroy this xdg_wm_base object.
+ *
+ * Destroying a bound xdg_wm_base object while there are surfaces
+ * still alive created by this xdg_wm_base object instance is illegal
+ * and will result in a defunct_surfaces error.
+ */
+static inline void
+xdg_wm_base_destroy(struct xdg_wm_base *xdg_wm_base)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
+			 XDG_WM_BASE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), WL_MARSHAL_FLAG_DESTROY);
+}
+
+/**
+ * @ingroup iface_xdg_wm_base
+ *
+ * Create a positioner object. A positioner object is used to position
+ * surfaces relative to some parent surface. See the interface description
+ * and xdg_surface.get_popup for details.
+ */
+static inline struct xdg_positioner *
+xdg_wm_base_create_positioner(struct xdg_wm_base *xdg_wm_base)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
+			 XDG_WM_BASE_CREATE_POSITIONER, &xdg_positioner_interface, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, NULL);
+
+	return (struct xdg_positioner *) id;
+}
+
+/**
+ * @ingroup iface_xdg_wm_base
+ *
+ * This creates an xdg_surface for the given surface. While xdg_surface
+ * itself is not a role, the corresponding surface may only be assigned
+ * a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
+ * illegal to create an xdg_surface for a wl_surface which already has an
+ * assigned role and this will result in a role error.
+ *
+ * This creates an xdg_surface for the given surface. An xdg_surface is
+ * used as basis to define a role to a given surface, such as xdg_toplevel
+ * or xdg_popup. It also manages functionality shared between xdg_surface
+ * based surface roles.
+ *
+ * See the documentation of xdg_surface for more details about what an
+ * xdg_surface is and how it is used.
+ */
+static inline struct xdg_surface *
+xdg_wm_base_get_xdg_surface(struct xdg_wm_base *xdg_wm_base, struct wl_surface *surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
+			 XDG_WM_BASE_GET_XDG_SURFACE, &xdg_surface_interface, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, NULL, surface);
+
+	return (struct xdg_surface *) id;
+}
+
+/**
+ * @ingroup iface_xdg_wm_base
+ *
+ * A client must respond to a ping event with a pong request or
+ * the client may be deemed unresponsive. See xdg_wm_base.ping
+ * and xdg_wm_base.error.unresponsive.
+ */
+static inline void
+xdg_wm_base_pong(struct xdg_wm_base *xdg_wm_base, uint32_t serial)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
+			 XDG_WM_BASE_PONG, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, serial);
+}
+
+#ifndef XDG_POSITIONER_ERROR_ENUM
+#define XDG_POSITIONER_ERROR_ENUM
+enum xdg_positioner_error {
+	/**
+	 * invalid input provided
+	 */
+	XDG_POSITIONER_ERROR_INVALID_INPUT = 0,
+};
+#endif /* XDG_POSITIONER_ERROR_ENUM */
+
+#ifndef XDG_POSITIONER_ANCHOR_ENUM
+#define XDG_POSITIONER_ANCHOR_ENUM
+enum xdg_positioner_anchor {
+	XDG_POSITIONER_ANCHOR_NONE = 0,
+	XDG_POSITIONER_ANCHOR_TOP = 1,
+	XDG_POSITIONER_ANCHOR_BOTTOM = 2,
+	XDG_POSITIONER_ANCHOR_LEFT = 3,
+	XDG_POSITIONER_ANCHOR_RIGHT = 4,
+	XDG_POSITIONER_ANCHOR_TOP_LEFT = 5,
+	XDG_POSITIONER_ANCHOR_BOTTOM_LEFT = 6,
+	XDG_POSITIONER_ANCHOR_TOP_RIGHT = 7,
+	XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT = 8,
+};
+#endif /* XDG_POSITIONER_ANCHOR_ENUM */
+
+#ifndef XDG_POSITIONER_GRAVITY_ENUM
+#define XDG_POSITIONER_GRAVITY_ENUM
+enum xdg_positioner_gravity {
+	XDG_POSITIONER_GRAVITY_NONE = 0,
+	XDG_POSITIONER_GRAVITY_TOP = 1,
+	XDG_POSITIONER_GRAVITY_BOTTOM = 2,
+	XDG_POSITIONER_GRAVITY_LEFT = 3,
+	XDG_POSITIONER_GRAVITY_RIGHT = 4,
+	XDG_POSITIONER_GRAVITY_TOP_LEFT = 5,
+	XDG_POSITIONER_GRAVITY_BOTTOM_LEFT = 6,
+	XDG_POSITIONER_GRAVITY_TOP_RIGHT = 7,
+	XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT = 8,
+};
+#endif /* XDG_POSITIONER_GRAVITY_ENUM */
+
+#ifndef XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
+#define XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
+/**
+ * @ingroup iface_xdg_positioner
+ * constraint adjustments
+ *
+ * The constraint adjustment value define ways the compositor will adjust
+ * the position of the surface, if the unadjusted position would result
+ * in the surface being partly constrained.
+ *
+ * Whether a surface is considered 'constrained' is left to the compositor
+ * to determine. For example, the surface may be partly outside the
+ * compositor's defined 'work area', thus necessitating the child surface's
+ * position be adjusted until it is entirely inside the work area.
+ *
+ * The adjustments can be combined, according to a defined precedence: 1)
+ * Flip, 2) Slide, 3) Resize.
+ */
+enum xdg_positioner_constraint_adjustment {
+	/**
+	 * don't move the child surface when constrained
+	 *
+	 * Don't alter the surface position even if it is constrained on
+	 * some axis, for example partially outside the edge of an output.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE = 0,
+	/**
+	 * move along the x axis until unconstrained
+	 *
+	 * Slide the surface along the x axis until it is no longer
+	 * constrained.
+	 *
+	 * First try to slide towards the direction of the gravity on the x
+	 * axis until either the edge in the opposite direction of the
+	 * gravity is unconstrained or the edge in the direction of the
+	 * gravity is constrained.
+	 *
+	 * Then try to slide towards the opposite direction of the gravity
+	 * on the x axis until either the edge in the direction of the
+	 * gravity is unconstrained or the edge in the opposite direction
+	 * of the gravity is constrained.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1,
+	/**
+	 * move along the y axis until unconstrained
+	 *
+	 * Slide the surface along the y axis until it is no longer
+	 * constrained.
+	 *
+	 * First try to slide towards the direction of the gravity on the y
+	 * axis until either the edge in the opposite direction of the
+	 * gravity is unconstrained or the edge in the direction of the
+	 * gravity is constrained.
+	 *
+	 * Then try to slide towards the opposite direction of the gravity
+	 * on the y axis until either the edge in the direction of the
+	 * gravity is unconstrained or the edge in the opposite direction
+	 * of the gravity is constrained.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2,
+	/**
+	 * invert the anchor and gravity on the x axis
+	 *
+	 * Invert the anchor and gravity on the x axis if the surface is
+	 * constrained on the x axis. For example, if the left edge of the
+	 * surface is constrained, the gravity is 'left' and the anchor is
+	 * 'left', change the gravity to 'right' and the anchor to 'right'.
+	 *
+	 * If the adjusted position also ends up being constrained, the
+	 * resulting position of the flip_x adjustment will be the one
+	 * before the adjustment.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X = 4,
+	/**
+	 * invert the anchor and gravity on the y axis
+	 *
+	 * Invert the anchor and gravity on the y axis if the surface is
+	 * constrained on the y axis. For example, if the bottom edge of
+	 * the surface is constrained, the gravity is 'bottom' and the
+	 * anchor is 'bottom', change the gravity to 'top' and the anchor
+	 * to 'top'.
+	 *
+	 * The adjusted position is calculated given the original anchor
+	 * rectangle and offset, but with the new flipped anchor and
+	 * gravity values.
+	 *
+	 * If the adjusted position also ends up being constrained, the
+	 * resulting position of the flip_y adjustment will be the one
+	 * before the adjustment.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8,
+	/**
+	 * horizontally resize the surface
+	 *
+	 * Resize the surface horizontally so that it is completely
+	 * unconstrained.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16,
+	/**
+	 * vertically resize the surface
+	 *
+	 * Resize the surface vertically so that it is completely
+	 * unconstrained.
+	 */
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32,
+};
+#endif /* XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM */
+
+#define XDG_POSITIONER_DESTROY 0
+#define XDG_POSITIONER_SET_SIZE 1
+#define XDG_POSITIONER_SET_ANCHOR_RECT 2
+#define XDG_POSITIONER_SET_ANCHOR 3
+#define XDG_POSITIONER_SET_GRAVITY 4
+#define XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT 5
+#define XDG_POSITIONER_SET_OFFSET 6
+#define XDG_POSITIONER_SET_REACTIVE 7
+#define XDG_POSITIONER_SET_PARENT_SIZE 8
+#define XDG_POSITIONER_SET_PARENT_CONFIGURE 9
+
+
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_ANCHOR_RECT_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_ANCHOR_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_GRAVITY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_OFFSET_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_REACTIVE_SINCE_VERSION 3
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_PARENT_SIZE_SINCE_VERSION 3
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_PARENT_CONFIGURE_SINCE_VERSION 3
+
+/** @ingroup iface_xdg_positioner */
+static inline void
+xdg_positioner_set_user_data(struct xdg_positioner *xdg_positioner, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_positioner, user_data);
+}
+
+/** @ingroup iface_xdg_positioner */
+static inline void *
+xdg_positioner_get_user_data(struct xdg_positioner *xdg_positioner)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_positioner);
+}
+
+static inline uint32_t
+xdg_positioner_get_version(struct xdg_positioner *xdg_positioner)
+{
+	return wl_proxy_get_version((struct wl_proxy *) xdg_positioner);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Notify the compositor that the xdg_positioner will no longer be used.
+ */
+static inline void
+xdg_positioner_destroy(struct xdg_positioner *xdg_positioner)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), WL_MARSHAL_FLAG_DESTROY);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Set the size of the surface that is to be positioned with the positioner
+ * object. The size is in surface-local coordinates and corresponds to the
+ * window geometry. See xdg_surface.set_window_geometry.
+ *
+ * If a zero or negative size is set the invalid_input error is raised.
+ */
+static inline void
+xdg_positioner_set_size(struct xdg_positioner *xdg_positioner, int32_t width, int32_t height)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Specify the anchor rectangle within the parent surface that the child
+ * surface will be placed relative to. The rectangle is relative to the
+ * window geometry as defined by xdg_surface.set_window_geometry of the
+ * parent surface.
+ *
+ * When the xdg_positioner object is used to position a child surface, the
+ * anchor rectangle may not extend outside the window geometry of the
+ * positioned child's parent surface.
+ *
+ * If a negative size is set the invalid_input error is raised.
+ */
+static inline void
+xdg_positioner_set_anchor_rect(struct xdg_positioner *xdg_positioner, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_ANCHOR_RECT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Defines the anchor point for the anchor rectangle. The specified anchor
+ * is used derive an anchor point that the child surface will be
+ * positioned relative to. If a corner anchor is set (e.g. 'top_left' or
+ * 'bottom_right'), the anchor point will be at the specified corner;
+ * otherwise, the derived anchor point will be centered on the specified
+ * edge, or in the center of the anchor rectangle if no edge is specified.
+ */
+static inline void
+xdg_positioner_set_anchor(struct xdg_positioner *xdg_positioner, uint32_t anchor)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_ANCHOR, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, anchor);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Defines in what direction a surface should be positioned, relative to
+ * the anchor point of the parent surface. If a corner gravity is
+ * specified (e.g. 'bottom_right' or 'top_left'), then the child surface
+ * will be placed towards the specified gravity; otherwise, the child
+ * surface will be centered over the anchor point on any axis that had no
+ * gravity specified. If the gravity is not in the ‘gravity’ enum, an
+ * invalid_input error is raised.
+ */
+static inline void
+xdg_positioner_set_gravity(struct xdg_positioner *xdg_positioner, uint32_t gravity)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_GRAVITY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, gravity);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Specify how the window should be positioned if the originally intended
+ * position caused the surface to be constrained, meaning at least
+ * partially outside positioning boundaries set by the compositor. The
+ * adjustment is set by constructing a bitmask describing the adjustment to
+ * be made when the surface is constrained on that axis.
+ *
+ * If no bit for one axis is set, the compositor will assume that the child
+ * surface should not change its position on that axis when constrained.
+ *
+ * If more than one bit for one axis is set, the order of how adjustments
+ * are applied is specified in the corresponding adjustment descriptions.
+ *
+ * The default adjustment is none.
+ */
+static inline void
+xdg_positioner_set_constraint_adjustment(struct xdg_positioner *xdg_positioner, uint32_t constraint_adjustment)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, constraint_adjustment);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Specify the surface position offset relative to the position of the
+ * anchor on the anchor rectangle and the anchor on the surface. For
+ * example if the anchor of the anchor rectangle is at (x, y), the surface
+ * has the gravity bottom|right, and the offset is (ox, oy), the calculated
+ * surface position will be (x + ox, y + oy). The offset position of the
+ * surface is the one used for constraint testing. See
+ * set_constraint_adjustment.
+ *
+ * An example use case is placing a popup menu on top of a user interface
+ * element, while aligning the user interface element of the parent surface
+ * with some user interface element placed somewhere in the popup surface.
+ */
+static inline void
+xdg_positioner_set_offset(struct xdg_positioner *xdg_positioner, int32_t x, int32_t y)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_OFFSET, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, x, y);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * When set reactive, the surface is reconstrained if the conditions used
+ * for constraining changed, e.g. the parent window moved.
+ *
+ * If the conditions changed and the popup was reconstrained, an
+ * xdg_popup.configure event is sent with updated geometry, followed by an
+ * xdg_surface.configure event.
+ */
+static inline void
+xdg_positioner_set_reactive(struct xdg_positioner *xdg_positioner)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_REACTIVE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Set the parent window geometry the compositor should use when
+ * positioning the popup. The compositor may use this information to
+ * determine the future state the popup should be constrained using. If
+ * this doesn't match the dimension of the parent the popup is eventually
+ * positioned against, the behavior is undefined.
+ *
+ * The arguments are given in the surface-local coordinate space.
+ */
+static inline void
+xdg_positioner_set_parent_size(struct xdg_positioner *xdg_positioner, int32_t parent_width, int32_t parent_height)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_PARENT_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, parent_width, parent_height);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Set the serial of an xdg_surface.configure event this positioner will be
+ * used in response to. The compositor may use this information together
+ * with set_parent_size to determine what future state the popup should be
+ * constrained using.
+ */
+static inline void
+xdg_positioner_set_parent_configure(struct xdg_positioner *xdg_positioner, uint32_t serial)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_PARENT_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, serial);
+}
+
+#ifndef XDG_SURFACE_ERROR_ENUM
+#define XDG_SURFACE_ERROR_ENUM
+enum xdg_surface_error {
+	/**
+	 * Surface was not fully constructed
+	 */
+	XDG_SURFACE_ERROR_NOT_CONSTRUCTED = 1,
+	/**
+	 * Surface was already constructed
+	 */
+	XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED = 2,
+	/**
+	 * Attaching a buffer to an unconfigured surface
+	 */
+	XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER = 3,
+	/**
+	 * Invalid serial number when acking a configure event
+	 */
+	XDG_SURFACE_ERROR_INVALID_SERIAL = 4,
+	/**
+	 * Width or height was zero or negative
+	 */
+	XDG_SURFACE_ERROR_INVALID_SIZE = 5,
+	/**
+	 * Surface was destroyed before its role object
+	 */
+	XDG_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT = 6,
+};
+#endif /* XDG_SURFACE_ERROR_ENUM */
+
+/**
+ * @ingroup iface_xdg_surface
+ * @struct xdg_surface_listener
+ */
+struct xdg_surface_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * The configure event marks the end of a configure sequence. A
+	 * configure sequence is a set of one or more events configuring
+	 * the state of the xdg_surface, including the final
+	 * xdg_surface.configure event.
+	 *
+	 * Where applicable, xdg_surface surface roles will during a
+	 * configure sequence extend this event as a latched state sent as
+	 * events before the xdg_surface.configure event. Such events
+	 * should be considered to make up a set of atomically applied
+	 * configuration states, where the xdg_surface.configure commits
+	 * the accumulated state.
+	 *
+	 * Clients should arrange their surface for the new states, and
+	 * then send an ack_configure request with the serial sent in this
+	 * configure event at some point before committing the new surface.
+	 *
+	 * If the client receives multiple configure events before it can
+	 * respond to one, it is free to discard all but the last event it
+	 * received.
+	 * @param serial serial of the configure event
+	 */
+	void (*configure)(void *data,
+			  struct xdg_surface *xdg_surface,
+			  uint32_t serial);
+};
+
+/**
+ * @ingroup iface_xdg_surface
+ */
+static inline int
+xdg_surface_add_listener(struct xdg_surface *xdg_surface,
+			 const struct xdg_surface_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) xdg_surface,
+				     (void (**)(void)) listener, data);
+}
+
+#define XDG_SURFACE_DESTROY 0
+#define XDG_SURFACE_GET_TOPLEVEL 1
+#define XDG_SURFACE_GET_POPUP 2
+#define XDG_SURFACE_SET_WINDOW_GEOMETRY 3
+#define XDG_SURFACE_ACK_CONFIGURE 4
+
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_GET_TOPLEVEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_GET_POPUP_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_SET_WINDOW_GEOMETRY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_ACK_CONFIGURE_SINCE_VERSION 1
+
+/** @ingroup iface_xdg_surface */
+static inline void
+xdg_surface_set_user_data(struct xdg_surface *xdg_surface, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_surface, user_data);
+}
+
+/** @ingroup iface_xdg_surface */
+static inline void *
+xdg_surface_get_user_data(struct xdg_surface *xdg_surface)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_surface);
+}
+
+static inline uint32_t
+xdg_surface_get_version(struct xdg_surface *xdg_surface)
+{
+	return wl_proxy_get_version((struct wl_proxy *) xdg_surface);
+}
+
+/**
+ * @ingroup iface_xdg_surface
+ *
+ * Destroy the xdg_surface object. An xdg_surface must only be destroyed
+ * after its role object has been destroyed, otherwise
+ * a defunct_role_object error is raised.
+ */
+static inline void
+xdg_surface_destroy(struct xdg_surface *xdg_surface)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), WL_MARSHAL_FLAG_DESTROY);
+}
+
+/**
+ * @ingroup iface_xdg_surface
+ *
+ * This creates an xdg_toplevel object for the given xdg_surface and gives
+ * the associated wl_surface the xdg_toplevel role.
+ *
+ * See the documentation of xdg_toplevel for more details about what an
+ * xdg_toplevel is and how it is used.
+ */
+static inline struct xdg_toplevel *
+xdg_surface_get_toplevel(struct xdg_surface *xdg_surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_GET_TOPLEVEL, &xdg_toplevel_interface, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, NULL);
+
+	return (struct xdg_toplevel *) id;
+}
+
+/**
+ * @ingroup iface_xdg_surface
+ *
+ * This creates an xdg_popup object for the given xdg_surface and gives
+ * the associated wl_surface the xdg_popup role.
+ *
+ * If null is passed as a parent, a parent surface must be specified using
+ * some other protocol, before committing the initial state.
+ *
+ * See the documentation of xdg_popup for more details about what an
+ * xdg_popup is and how it is used.
+ */
+static inline struct xdg_popup *
+xdg_surface_get_popup(struct xdg_surface *xdg_surface, struct xdg_surface *parent, struct xdg_positioner *positioner)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_GET_POPUP, &xdg_popup_interface, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, NULL, parent, positioner);
+
+	return (struct xdg_popup *) id;
+}
+
+/**
+ * @ingroup iface_xdg_surface
+ *
+ * The window geometry of a surface is its "visible bounds" from the
+ * user's perspective. Client-side decorations often have invisible
+ * portions like drop-shadows which should be ignored for the
+ * purposes of aligning, placing and constraining windows.
+ *
+ * The window geometry is double buffered, and will be applied at the
+ * time wl_surface.commit of the corresponding wl_surface is called.
+ *
+ * When maintaining a position, the compositor should treat the (x, y)
+ * coordinate of the window geometry as the top left corner of the window.
+ * A client changing the (x, y) window geometry coordinate should in
+ * general not alter the position of the window.
+ *
+ * Once the window geometry of the surface is set, it is not possible to
+ * unset it, and it will remain the same until set_window_geometry is
+ * called again, even if a new subsurface or buffer is attached.
+ *
+ * If never set, the value is the full bounds of the surface,
+ * including any subsurfaces. This updates dynamically on every
+ * commit. This unset is meant for extremely simple clients.
+ *
+ * The arguments are given in the surface-local coordinate space of
+ * the wl_surface associated with this xdg_surface, and may extend outside
+ * of the wl_surface itself to mark parts of the subsurface tree as part of
+ * the window geometry.
+ *
+ * When applied, the effective window geometry will be the set window
+ * geometry clamped to the bounding rectangle of the combined
+ * geometry of the surface of the xdg_surface and the associated
+ * subsurfaces.
+ *
+ * The effective geometry will not be recalculated unless a new call to
+ * set_window_geometry is done and the new pending surface state is
+ * subsequently applied.
+ *
+ * The width and height of the effective window geometry must be
+ * greater than zero. Setting an invalid size will raise an
+ * invalid_size error.
+ */
+static inline void
+xdg_surface_set_window_geometry(struct xdg_surface *xdg_surface, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_SET_WINDOW_GEOMETRY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_surface
+ *
+ * When a configure event is received, if a client commits the
+ * surface in response to the configure event, then the client
+ * must make an ack_configure request sometime before the commit
+ * request, passing along the serial of the configure event.
+ *
+ * For instance, for toplevel surfaces the compositor might use this
+ * information to move a surface to the top left only when the client has
+ * drawn itself for the maximized or fullscreen state.
+ *
+ * If the client receives multiple configure events before it
+ * can respond to one, it only has to ack the last configure event.
+ * Acking a configure event that was never sent raises an invalid_serial
+ * error.
+ *
+ * A client is not required to commit immediately after sending
+ * an ack_configure request - it may even ack_configure several times
+ * before its next surface commit.
+ *
+ * A client may send multiple ack_configure requests before committing, but
+ * only the last request sent before a commit indicates which configure
+ * event the client really is responding to.
+ *
+ * Sending an ack_configure request consumes the serial number sent with
+ * the request, as well as serial numbers sent by all configure events
+ * sent on this xdg_surface prior to the configure event referenced by
+ * the committed serial.
+ *
+ * It is an error to issue multiple ack_configure requests referencing a
+ * serial from the same configure event, or to issue an ack_configure
+ * request referencing a serial from a configure event issued before the
+ * event identified by the last ack_configure request for the same
+ * xdg_surface. Doing so will raise an invalid_serial error.
+ */
+static inline void
+xdg_surface_ack_configure(struct xdg_surface *xdg_surface, uint32_t serial)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_ACK_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, serial);
+}
+
+#ifndef XDG_TOPLEVEL_ERROR_ENUM
+#define XDG_TOPLEVEL_ERROR_ENUM
+enum xdg_toplevel_error {
+	/**
+	 * provided value is         not a valid variant of the resize_edge enum
+	 */
+	XDG_TOPLEVEL_ERROR_INVALID_RESIZE_EDGE = 0,
+	/**
+	 * invalid parent toplevel
+	 */
+	XDG_TOPLEVEL_ERROR_INVALID_PARENT = 1,
+	/**
+	 * client provided an invalid min or max size
+	 */
+	XDG_TOPLEVEL_ERROR_INVALID_SIZE = 2,
+};
+#endif /* XDG_TOPLEVEL_ERROR_ENUM */
+
+#ifndef XDG_TOPLEVEL_RESIZE_EDGE_ENUM
+#define XDG_TOPLEVEL_RESIZE_EDGE_ENUM
+/**
+ * @ingroup iface_xdg_toplevel
+ * edge values for resizing
+ *
+ * These values are used to indicate which edge of a surface
+ * is being dragged in a resize operation.
+ */
+enum xdg_toplevel_resize_edge {
+	XDG_TOPLEVEL_RESIZE_EDGE_NONE = 0,
+	XDG_TOPLEVEL_RESIZE_EDGE_TOP = 1,
+	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM = 2,
+	XDG_TOPLEVEL_RESIZE_EDGE_LEFT = 4,
+	XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT = 5,
+	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT = 6,
+	XDG_TOPLEVEL_RESIZE_EDGE_RIGHT = 8,
+	XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT = 9,
+	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT = 10,
+};
+#endif /* XDG_TOPLEVEL_RESIZE_EDGE_ENUM */
+
+#ifndef XDG_TOPLEVEL_STATE_ENUM
+#define XDG_TOPLEVEL_STATE_ENUM
+/**
+ * @ingroup iface_xdg_toplevel
+ * types of state on the surface
+ *
+ * The different state values used on the surface. This is designed for
+ * state values like maximized, fullscreen. It is paired with the
+ * configure event to ensure that both the client and the compositor
+ * setting the state can be synchronized.
+ *
+ * States set in this way are double-buffered. They will get applied on
+ * the next commit.
+ */
+enum xdg_toplevel_state {
+	/**
+	 * the surface is maximized
+	 * the surface is maximized
+	 *
+	 * The surface is maximized. The window geometry specified in the
+	 * configure event must be obeyed by the client, or the
+	 * xdg_wm_base.invalid_surface_state error is raised.
+	 *
+	 * The client should draw without shadow or other decoration
+	 * outside of the window geometry.
+	 */
+	XDG_TOPLEVEL_STATE_MAXIMIZED = 1,
+	/**
+	 * the surface is fullscreen
+	 * the surface is fullscreen
+	 *
+	 * The surface is fullscreen. The window geometry specified in
+	 * the configure event is a maximum; the client cannot resize
+	 * beyond it. For a surface to cover the whole fullscreened area,
+	 * the geometry dimensions must be obeyed by the client. For more
+	 * details, see xdg_toplevel.set_fullscreen.
+	 */
+	XDG_TOPLEVEL_STATE_FULLSCREEN = 2,
+	/**
+	 * the surface is being resized
+	 * the surface is being resized
+	 *
+	 * The surface is being resized. The window geometry specified in
+	 * the configure event is a maximum; the client cannot resize
+	 * beyond it. Clients that have aspect ratio or cell sizing
+	 * configuration can use a smaller size, however.
+	 */
+	XDG_TOPLEVEL_STATE_RESIZING = 3,
+	/**
+	 * the surface is now activated
+	 * the surface is now activated
+	 *
+	 * Client window decorations should be painted as if the window
+	 * is active. Do not assume this means that the window actually has
+	 * keyboard or pointer focus.
+	 */
+	XDG_TOPLEVEL_STATE_ACTIVATED = 4,
+	/**
+	 * the surface’s left edge is tiled
+	 *
+	 * The window is currently in a tiled layout and the left edge is
+	 * considered to be adjacent to another part of the tiling grid.
+	 *
+	 * The client should draw without shadow or other decoration
+	 * outside of the window geometry on the left edge.
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_LEFT = 5,
+	/**
+	 * the surface’s right edge is tiled
+	 *
+	 * The window is currently in a tiled layout and the right edge
+	 * is considered to be adjacent to another part of the tiling grid.
+	 *
+	 * The client should draw without shadow or other decoration
+	 * outside of the window geometry on the right edge.
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_RIGHT = 6,
+	/**
+	 * the surface’s top edge is tiled
+	 *
+	 * The window is currently in a tiled layout and the top edge is
+	 * considered to be adjacent to another part of the tiling grid.
+	 *
+	 * The client should draw without shadow or other decoration
+	 * outside of the window geometry on the top edge.
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_TOP = 7,
+	/**
+	 * the surface’s bottom edge is tiled
+	 *
+	 * The window is currently in a tiled layout and the bottom edge
+	 * is considered to be adjacent to another part of the tiling grid.
+	 *
+	 * The client should draw without shadow or other decoration
+	 * outside of the window geometry on the bottom edge.
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_BOTTOM = 8,
+	/**
+	 * surface repaint is suspended
+	 *
+	 * The surface is currently not ordinarily being repainted; for
+	 * example because its content is occluded by another window, or
+	 * its outputs are switched off due to screen locking.
+	 * @since 6
+	 */
+	XDG_TOPLEVEL_STATE_SUSPENDED = 9,
+};
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_LEFT_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_RIGHT_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_TOP_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_BOTTOM_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_SUSPENDED_SINCE_VERSION 6
+#endif /* XDG_TOPLEVEL_STATE_ENUM */
+
+#ifndef XDG_TOPLEVEL_WM_CAPABILITIES_ENUM
+#define XDG_TOPLEVEL_WM_CAPABILITIES_ENUM
+enum xdg_toplevel_wm_capabilities {
+	/**
+	 * show_window_menu is available
+	 */
+	XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU = 1,
+	/**
+	 * set_maximized and unset_maximized are available
+	 */
+	XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE = 2,
+	/**
+	 * set_fullscreen and unset_fullscreen are available
+	 */
+	XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN = 3,
+	/**
+	 * set_minimized is available
+	 */
+	XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE = 4,
+};
+#endif /* XDG_TOPLEVEL_WM_CAPABILITIES_ENUM */
+
+/**
+ * @ingroup iface_xdg_toplevel
+ * @struct xdg_toplevel_listener
+ */
+struct xdg_toplevel_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * This configure event asks the client to resize its toplevel
+	 * surface or to change its state. The configured state should not
+	 * be applied immediately. See xdg_surface.configure for details.
+	 *
+	 * The width and height arguments specify a hint to the window
+	 * about how its surface should be resized in window geometry
+	 * coordinates. See set_window_geometry.
+	 *
+	 * If the width or height arguments are zero, it means the client
+	 * should decide its own window dimension. This may happen when the
+	 * compositor needs to configure the state of the surface but
+	 * doesn't have any information about any previous or expected
+	 * dimension.
+	 *
+	 * The states listed in the event specify how the width/height
+	 * arguments should be interpreted, and possibly how it should be
+	 * drawn.
+	 *
+	 * Clients must send an ack_configure in response to this event.
+	 * See xdg_surface.configure and xdg_surface.ack_configure for
+	 * details.
+	 */
+	void (*configure)(void *data,
+			  struct xdg_toplevel *xdg_toplevel,
+			  int32_t width,
+			  int32_t height,
+			  struct wl_array *states);
+	/**
+	 * surface wants to be closed
+	 *
+	 * The close event is sent by the compositor when the user wants
+	 * the surface to be closed. This should be equivalent to the user
+	 * clicking the close button in client-side decorations, if your
+	 * application has any.
+	 *
+	 * This is only a request that the user intends to close the
+	 * window. The client may choose to ignore this request, or show a
+	 * dialog to ask the user to save their data, etc.
+	 */
+	void (*close)(void *data,
+		      struct xdg_toplevel *xdg_toplevel);
+	/**
+	 * recommended window geometry bounds
+	 *
+	 * The configure_bounds event may be sent prior to a
+	 * xdg_toplevel.configure event to communicate the bounds a window
+	 * geometry size is recommended to constrain to.
+	 *
+	 * The passed width and height are in surface coordinate space. If
+	 * width and height are 0, it means bounds is unknown and
+	 * equivalent to as if no configure_bounds event was ever sent for
+	 * this surface.
+	 *
+	 * The bounds can for example correspond to the size of a monitor
+	 * excluding any panels or other shell components, so that a
+	 * surface isn't created in a way that it cannot fit.
+	 *
+	 * The bounds may change at any point, and in such a case, a new
+	 * xdg_toplevel.configure_bounds will be sent, followed by
+	 * xdg_toplevel.configure and xdg_surface.configure.
+	 * @since 4
+	 */
+	void (*configure_bounds)(void *data,
+				 struct xdg_toplevel *xdg_toplevel,
+				 int32_t width,
+				 int32_t height);
+	/**
+	 * compositor capabilities
+	 *
+	 * This event advertises the capabilities supported by the
+	 * compositor. If a capability isn't supported, clients should hide
+	 * or disable the UI elements that expose this functionality. For
+	 * instance, if the compositor doesn't advertise support for
+	 * minimized toplevels, a button triggering the set_minimized
+	 * request should not be displayed.
+	 *
+	 * The compositor will ignore requests it doesn't support. For
+	 * instance, a compositor which doesn't advertise support for
+	 * minimized will ignore set_minimized requests.
+	 *
+	 * Compositors must send this event once before the first
+	 * xdg_surface.configure event. When the capabilities change,
+	 * compositors must send this event again and then send an
+	 * xdg_surface.configure event.
+	 *
+	 * The configured state should not be applied immediately. See
+	 * xdg_surface.configure for details.
+	 *
+	 * The capabilities are sent as an array of 32-bit unsigned
+	 * integers in native endianness.
+	 * @param capabilities array of 32-bit capabilities
+	 * @since 5
+	 */
+	void (*wm_capabilities)(void *data,
+				struct xdg_toplevel *xdg_toplevel,
+				struct wl_array *capabilities);
+};
+
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+static inline int
+xdg_toplevel_add_listener(struct xdg_toplevel *xdg_toplevel,
+			  const struct xdg_toplevel_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) xdg_toplevel,
+				     (void (**)(void)) listener, data);
+}
+
+#define XDG_TOPLEVEL_DESTROY 0
+#define XDG_TOPLEVEL_SET_PARENT 1
+#define XDG_TOPLEVEL_SET_TITLE 2
+#define XDG_TOPLEVEL_SET_APP_ID 3
+#define XDG_TOPLEVEL_SHOW_WINDOW_MENU 4
+#define XDG_TOPLEVEL_MOVE 5
+#define XDG_TOPLEVEL_RESIZE 6
+#define XDG_TOPLEVEL_SET_MAX_SIZE 7
+#define XDG_TOPLEVEL_SET_MIN_SIZE 8
+#define XDG_TOPLEVEL_SET_MAXIMIZED 9
+#define XDG_TOPLEVEL_UNSET_MAXIMIZED 10
+#define XDG_TOPLEVEL_SET_FULLSCREEN 11
+#define XDG_TOPLEVEL_UNSET_FULLSCREEN 12
+#define XDG_TOPLEVEL_SET_MINIMIZED 13
+
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_CLOSE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_CONFIGURE_BOUNDS_SINCE_VERSION 4
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_WM_CAPABILITIES_SINCE_VERSION 5
+
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_PARENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_TITLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_APP_ID_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SHOW_WINDOW_MENU_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_MOVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_RESIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MAX_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MIN_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_UNSET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_UNSET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MINIMIZED_SINCE_VERSION 1
+
+/** @ingroup iface_xdg_toplevel */
+static inline void
+xdg_toplevel_set_user_data(struct xdg_toplevel *xdg_toplevel, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_toplevel, user_data);
+}
+
+/** @ingroup iface_xdg_toplevel */
+static inline void *
+xdg_toplevel_get_user_data(struct xdg_toplevel *xdg_toplevel)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_toplevel);
+}
+
+static inline uint32_t
+xdg_toplevel_get_version(struct xdg_toplevel *xdg_toplevel)
+{
+	return wl_proxy_get_version((struct wl_proxy *) xdg_toplevel);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * This request destroys the role surface and unmaps the surface;
+ * see "Unmapping" behavior in interface section for details.
+ */
+static inline void
+xdg_toplevel_destroy(struct xdg_toplevel *xdg_toplevel)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), WL_MARSHAL_FLAG_DESTROY);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Set the "parent" of this surface. This surface should be stacked
+ * above the parent surface and all other ancestor surfaces.
+ *
+ * Parent surfaces should be set on dialogs, toolboxes, or other
+ * "auxiliary" surfaces, so that the parent is raised when the dialog
+ * is raised.
+ *
+ * Setting a null parent for a child surface unsets its parent. Setting
+ * a null parent for a surface which currently has no parent is a no-op.
+ *
+ * Only mapped surfaces can have child surfaces. Setting a parent which
+ * is not mapped is equivalent to setting a null parent. If a surface
+ * becomes unmapped, its children's parent is set to the parent of
+ * the now-unmapped surface. If the now-unmapped surface has no parent,
+ * its children's parent is unset. If the now-unmapped surface becomes
+ * mapped again, its parent-child relationship is not restored.
+ *
+ * The parent toplevel must not be one of the child toplevel's
+ * descendants, and the parent must be different from the child toplevel,
+ * otherwise the invalid_parent protocol error is raised.
+ */
+static inline void
+xdg_toplevel_set_parent(struct xdg_toplevel *xdg_toplevel, struct xdg_toplevel *parent)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_PARENT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, parent);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Set a short title for the surface.
+ *
+ * This string may be used to identify the surface in a task bar,
+ * window list, or other user interface elements provided by the
+ * compositor.
+ *
+ * The string must be encoded in UTF-8.
+ */
+static inline void
+xdg_toplevel_set_title(struct xdg_toplevel *xdg_toplevel, const char *title)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_TITLE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, title);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Set an application identifier for the surface.
+ *
+ * The app ID identifies the general class of applications to which
+ * the surface belongs. The compositor can use this to group multiple
+ * surfaces together, or to determine how to launch a new application.
+ *
+ * For D-Bus activatable applications, the app ID is used as the D-Bus
+ * service name.
+ *
+ * The compositor shell will try to group application surfaces together
+ * by their app ID. As a best practice, it is suggested to select app
+ * ID's that match the basename of the application's .desktop file.
+ * For example, "org.freedesktop.FooViewer" where the .desktop file is
+ * "org.freedesktop.FooViewer.desktop".
+ *
+ * Like other properties, a set_app_id request can be sent after the
+ * xdg_toplevel has been mapped to update the property.
+ *
+ * See the desktop-entry specification [0] for more details on
+ * application identifiers and how they relate to well-known D-Bus
+ * names and .desktop files.
+ *
+ * [0] https://standards.freedesktop.org/desktop-entry-spec/
+ */
+static inline void
+xdg_toplevel_set_app_id(struct xdg_toplevel *xdg_toplevel, const char *app_id)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_APP_ID, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, app_id);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Clients implementing client-side decorations might want to show
+ * a context menu when right-clicking on the decorations, giving the
+ * user a menu that they can use to maximize or minimize the window.
+ *
+ * This request asks the compositor to pop up such a window menu at
+ * the given position, relative to the local surface coordinates of
+ * the parent surface. There are no guarantees as to what menu items
+ * the window menu contains, or even if a window menu will be drawn
+ * at all.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event.
+ */
+static inline void
+xdg_toplevel_show_window_menu(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial, int32_t x, int32_t y)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SHOW_WINDOW_MENU, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial, x, y);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Start an interactive, user-driven move of the surface.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event. The passed
+ * serial is used to determine the type of interactive move (touch,
+ * pointer, etc).
+ *
+ * The server may ignore move requests depending on the state of
+ * the surface (e.g. fullscreen or maximized), or if the passed serial
+ * is no longer valid.
+ *
+ * If triggered, the surface will lose the focus of the device
+ * (wl_pointer, wl_touch, etc) used for the move. It is up to the
+ * compositor to visually indicate that the move is taking place, such as
+ * updating a pointer cursor, during the move. There is no guarantee
+ * that the device focus will return when the move is completed.
+ */
+static inline void
+xdg_toplevel_move(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_MOVE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Start a user-driven, interactive resize of the surface.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event. The passed
+ * serial is used to determine the type of interactive resize (touch,
+ * pointer, etc).
+ *
+ * The server may ignore resize requests depending on the state of
+ * the surface (e.g. fullscreen or maximized).
+ *
+ * If triggered, the client will receive configure events with the
+ * "resize" state enum value and the expected sizes. See the "resize"
+ * enum value for more details about what is required. The client
+ * must also acknowledge configure events using "ack_configure". After
+ * the resize is completed, the client will receive another "configure"
+ * event without the resize state.
+ *
+ * If triggered, the surface also will lose the focus of the device
+ * (wl_pointer, wl_touch, etc) used for the resize. It is up to the
+ * compositor to visually indicate that the resize is taking place,
+ * such as updating a pointer cursor, during the resize. There is no
+ * guarantee that the device focus will return when the resize is
+ * completed.
+ *
+ * The edges parameter specifies how the surface should be resized, and
+ * is one of the values of the resize_edge enum. Values not matching
+ * a variant of the enum will cause the invalid_resize_edge protocol error.
+ * The compositor may use this information to update the surface position
+ * for example when dragging the top left corner. The compositor may also
+ * use this information to adapt its behavior, e.g. choose an appropriate
+ * cursor image.
+ */
+static inline void
+xdg_toplevel_resize(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial, uint32_t edges)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_RESIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial, edges);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Set a maximum size for the window.
+ *
+ * The client can specify a maximum size so that the compositor does
+ * not try to configure the window beyond this size.
+ *
+ * The width and height arguments are in window geometry coordinates.
+ * See xdg_surface.set_window_geometry.
+ *
+ * Values set in this way are double-buffered. They will get applied
+ * on the next commit.
+ *
+ * The compositor can use this information to allow or disallow
+ * different states like maximize or fullscreen and draw accurate
+ * animations.
+ *
+ * Similarly, a tiling window manager may use this information to
+ * place and resize client windows in a more effective way.
+ *
+ * The client should not rely on the compositor to obey the maximum
+ * size. The compositor may decide to ignore the values set by the
+ * client and request a larger size.
+ *
+ * If never set, or a value of zero in the request, means that the
+ * client has no expected maximum size in the given dimension.
+ * As a result, a client wishing to reset the maximum size
+ * to an unspecified state can use zero for width and height in the
+ * request.
+ *
+ * Requesting a maximum size to be smaller than the minimum size of
+ * a surface is illegal and will result in an invalid_size error.
+ *
+ * The width and height must be greater than or equal to zero. Using
+ * strictly negative values for width or height will result in a
+ * invalid_size error.
+ */
+static inline void
+xdg_toplevel_set_max_size(struct xdg_toplevel *xdg_toplevel, int32_t width, int32_t height)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_MAX_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Set a minimum size for the window.
+ *
+ * The client can specify a minimum size so that the compositor does
+ * not try to configure the window below this size.
+ *
+ * The width and height arguments are in window geometry coordinates.
+ * See xdg_surface.set_window_geometry.
+ *
+ * Values set in this way are double-buffered. They will get applied
+ * on the next commit.
+ *
+ * The compositor can use this information to allow or disallow
+ * different states like maximize or fullscreen and draw accurate
+ * animations.
+ *
+ * Similarly, a tiling window manager may use this information to
+ * place and resize client windows in a more effective way.
+ *
+ * The client should not rely on the compositor to obey the minimum
+ * size. The compositor may decide to ignore the values set by the
+ * client and request a smaller size.
+ *
+ * If never set, or a value of zero in the request, means that the
+ * client has no expected minimum size in the given dimension.
+ * As a result, a client wishing to reset the minimum size
+ * to an unspecified state can use zero for width and height in the
+ * request.
+ *
+ * Requesting a minimum size to be larger than the maximum size of
+ * a surface is illegal and will result in an invalid_size error.
+ *
+ * The width and height must be greater than or equal to zero. Using
+ * strictly negative values for width and height will result in a
+ * invalid_size error.
+ */
+static inline void
+xdg_toplevel_set_min_size(struct xdg_toplevel *xdg_toplevel, int32_t width, int32_t height)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_MIN_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Maximize the surface.
+ *
+ * After requesting that the surface should be maximized, the compositor
+ * will respond by emitting a configure event. Whether this configure
+ * actually sets the window maximized is subject to compositor policies.
+ * The client must then update its content, drawing in the configured
+ * state. The client must also acknowledge the configure when committing
+ * the new content (see ack_configure).
+ *
+ * It is up to the compositor to decide how and where to maximize the
+ * surface, for example which output and what region of the screen should
+ * be used.
+ *
+ * If the surface was already maximized, the compositor will still emit
+ * a configure event with the "maximized" state.
+ *
+ * If the surface is in a fullscreen state, this request has no direct
+ * effect. It may alter the state the surface is returned to when
+ * unmaximized unless overridden by the compositor.
+ */
+static inline void
+xdg_toplevel_set_maximized(struct xdg_toplevel *xdg_toplevel)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_MAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Unmaximize the surface.
+ *
+ * After requesting that the surface should be unmaximized, the compositor
+ * will respond by emitting a configure event. Whether this actually
+ * un-maximizes the window is subject to compositor policies.
+ * If available and applicable, the compositor will include the window
+ * geometry dimensions the window had prior to being maximized in the
+ * configure event. The client must then update its content, drawing it in
+ * the configured state. The client must also acknowledge the configure
+ * when committing the new content (see ack_configure).
+ *
+ * It is up to the compositor to position the surface after it was
+ * unmaximized; usually the position the surface had before maximizing, if
+ * applicable.
+ *
+ * If the surface was already not maximized, the compositor will still
+ * emit a configure event without the "maximized" state.
+ *
+ * If the surface is in a fullscreen state, this request has no direct
+ * effect. It may alter the state the surface is returned to when
+ * unmaximized unless overridden by the compositor.
+ */
+static inline void
+xdg_toplevel_unset_maximized(struct xdg_toplevel *xdg_toplevel)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_UNSET_MAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Make the surface fullscreen.
+ *
+ * After requesting that the surface should be fullscreened, the
+ * compositor will respond by emitting a configure event. Whether the
+ * client is actually put into a fullscreen state is subject to compositor
+ * policies. The client must also acknowledge the configure when
+ * committing the new content (see ack_configure).
+ *
+ * The output passed by the request indicates the client's preference as
+ * to which display it should be set fullscreen on. If this value is NULL,
+ * it's up to the compositor to choose which display will be used to map
+ * this surface.
+ *
+ * If the surface doesn't cover the whole output, the compositor will
+ * position the surface in the center of the output and compensate with
+ * with border fill covering the rest of the output. The content of the
+ * border fill is undefined, but should be assumed to be in some way that
+ * attempts to blend into the surrounding area (e.g. solid black).
+ *
+ * If the fullscreened surface is not opaque, the compositor must make
+ * sure that other screen content not part of the same surface tree (made
+ * up of subsurfaces, popups or similarly coupled surfaces) are not
+ * visible below the fullscreened surface.
+ */
+static inline void
+xdg_toplevel_set_fullscreen(struct xdg_toplevel *xdg_toplevel, struct wl_output *output)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, output);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Make the surface no longer fullscreen.
+ *
+ * After requesting that the surface should be unfullscreened, the
+ * compositor will respond by emitting a configure event.
+ * Whether this actually removes the fullscreen state of the client is
+ * subject to compositor policies.
+ *
+ * Making a surface unfullscreen sets states for the surface based on the following:
+ * * the state(s) it may have had before becoming fullscreen
+ * * any state(s) decided by the compositor
+ * * any state(s) requested by the client while the surface was fullscreen
+ *
+ * The compositor may include the previous window geometry dimensions in
+ * the configure event, if applicable.
+ *
+ * The client must also acknowledge the configure when committing the new
+ * content (see ack_configure).
+ */
+static inline void
+xdg_toplevel_unset_fullscreen(struct xdg_toplevel *xdg_toplevel)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_UNSET_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Request that the compositor minimize your surface. There is no
+ * way to know if the surface is currently minimized, nor is there
+ * any way to unset minimization on this surface.
+ *
+ * If you are looking to throttle redrawing when minimized, please
+ * instead use the wl_surface.frame event for this, as this will
+ * also work with live previews on windows in Alt-Tab, Expose or
+ * similar compositor features.
+ */
+static inline void
+xdg_toplevel_set_minimized(struct xdg_toplevel *xdg_toplevel)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_MINIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
+}
+
+#ifndef XDG_POPUP_ERROR_ENUM
+#define XDG_POPUP_ERROR_ENUM
+enum xdg_popup_error {
+	/**
+	 * tried to grab after being mapped
+	 */
+	XDG_POPUP_ERROR_INVALID_GRAB = 0,
+};
+#endif /* XDG_POPUP_ERROR_ENUM */
+
+/**
+ * @ingroup iface_xdg_popup
+ * @struct xdg_popup_listener
+ */
+struct xdg_popup_listener {
+	/**
+	 * configure the popup surface
+	 *
+	 * This event asks the popup surface to configure itself given
+	 * the configuration. The configured state should not be applied
+	 * immediately. See xdg_surface.configure for details.
+	 *
+	 * The x and y arguments represent the position the popup was
+	 * placed at given the xdg_positioner rule, relative to the upper
+	 * left corner of the window geometry of the parent surface.
+	 *
+	 * For version 2 or older, the configure event for an xdg_popup is
+	 * only ever sent once for the initial configuration. Starting with
+	 * version 3, it may be sent again if the popup is setup with an
+	 * xdg_positioner with set_reactive requested, or in response to
+	 * xdg_popup.reposition requests.
+	 * @param x x position relative to parent surface window geometry
+	 * @param y y position relative to parent surface window geometry
+	 * @param width window geometry width
+	 * @param height window geometry height
+	 */
+	void (*configure)(void *data,
+			  struct xdg_popup *xdg_popup,
+			  int32_t x,
+			  int32_t y,
+			  int32_t width,
+			  int32_t height);
+	/**
+	 * popup interaction is done
+	 *
+	 * The popup_done event is sent out when a popup is dismissed by
+	 * the compositor. The client should destroy the xdg_popup object
+	 * at this point.
+	 */
+	void (*popup_done)(void *data,
+			   struct xdg_popup *xdg_popup);
+	/**
+	 * signal the completion of a repositioned request
+	 *
+	 * The repositioned event is sent as part of a popup
+	 * configuration sequence, together with xdg_popup.configure and
+	 * lastly xdg_surface.configure to notify the completion of a
+	 * reposition request.
+	 *
+	 * The repositioned event is to notify about the completion of a
+	 * xdg_popup.reposition request. The token argument is the token
+	 * passed in the xdg_popup.reposition request.
+	 *
+	 * Immediately after this event is emitted, xdg_popup.configure and
+	 * xdg_surface.configure will be sent with the updated size and
+	 * position, as well as a new configure serial.
+	 *
+	 * The client should optionally update the content of the popup,
+	 * but must acknowledge the new popup configuration for the new
+	 * position to take effect. See xdg_surface.ack_configure for
+	 * details.
+	 * @param token reposition request token
+	 * @since 3
+	 */
+	void (*repositioned)(void *data,
+			     struct xdg_popup *xdg_popup,
+			     uint32_t token);
+};
+
+/**
+ * @ingroup iface_xdg_popup
+ */
+static inline int
+xdg_popup_add_listener(struct xdg_popup *xdg_popup,
+		       const struct xdg_popup_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) xdg_popup,
+				     (void (**)(void)) listener, data);
+}
+
+#define XDG_POPUP_DESTROY 0
+#define XDG_POPUP_GRAB 1
+#define XDG_POPUP_REPOSITION 2
+
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_POPUP_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_REPOSITIONED_SINCE_VERSION 3
+
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_GRAB_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_REPOSITION_SINCE_VERSION 3
+
+/** @ingroup iface_xdg_popup */
+static inline void
+xdg_popup_set_user_data(struct xdg_popup *xdg_popup, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_popup, user_data);
+}
+
+/** @ingroup iface_xdg_popup */
+static inline void *
+xdg_popup_get_user_data(struct xdg_popup *xdg_popup)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_popup);
+}
+
+static inline uint32_t
+xdg_popup_get_version(struct xdg_popup *xdg_popup)
+{
+	return wl_proxy_get_version((struct wl_proxy *) xdg_popup);
+}
+
+/**
+ * @ingroup iface_xdg_popup
+ *
+ * This destroys the popup. Explicitly destroying the xdg_popup
+ * object will also dismiss the popup, and unmap the surface.
+ *
+ * If this xdg_popup is not the "topmost" popup, the
+ * xdg_wm_base.not_the_topmost_popup protocol error will be sent.
+ */
+static inline void
+xdg_popup_destroy(struct xdg_popup *xdg_popup)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
+			 XDG_POPUP_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), WL_MARSHAL_FLAG_DESTROY);
+}
+
+/**
+ * @ingroup iface_xdg_popup
+ *
+ * This request makes the created popup take an explicit grab. An explicit
+ * grab will be dismissed when the user dismisses the popup, or when the
+ * client destroys the xdg_popup. This can be done by the user clicking
+ * outside the surface, using the keyboard, or even locking the screen
+ * through closing the lid or a timeout.
+ *
+ * If the compositor denies the grab, the popup will be immediately
+ * dismissed.
+ *
+ * This request must be used in response to some sort of user action like a
+ * button press, key press, or touch down event. The serial number of the
+ * event should be passed as 'serial'.
+ *
+ * The parent of a grabbing popup must either be an xdg_toplevel surface or
+ * another xdg_popup with an explicit grab. If the parent is another
+ * xdg_popup it means that the popups are nested, with this popup now being
+ * the topmost popup.
+ *
+ * Nested popups must be destroyed in the reverse order they were created
+ * in, e.g. the only popup you are allowed to destroy at all times is the
+ * topmost one.
+ *
+ * When compositors choose to dismiss a popup, they may dismiss every
+ * nested grabbing popup as well. When a compositor dismisses popups, it
+ * will follow the same dismissing order as required from the client.
+ *
+ * If the topmost grabbing popup is destroyed, the grab will be returned to
+ * the parent of the popup, if that parent previously had an explicit grab.
+ *
+ * If the parent is a grabbing popup which has already been dismissed, this
+ * popup will be immediately dismissed. If the parent is a popup that did
+ * not take an explicit grab, an error will be raised.
+ *
+ * During a popup grab, the client owning the grab will receive pointer
+ * and touch events for all their surfaces as normal (similar to an
+ * "owner-events" grab in X11 parlance), while the top most grabbing popup
+ * will always have keyboard focus.
+ */
+static inline void
+xdg_popup_grab(struct xdg_popup *xdg_popup, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
+			 XDG_POPUP_GRAB, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), 0, seat, serial);
+}
+
+/**
+ * @ingroup iface_xdg_popup
+ *
+ * Reposition an already-mapped popup. The popup will be placed given the
+ * details in the passed xdg_positioner object, and a
+ * xdg_popup.repositioned followed by xdg_popup.configure and
+ * xdg_surface.configure will be emitted in response. Any parameters set
+ * by the previous positioner will be discarded.
+ *
+ * The passed token will be sent in the corresponding
+ * xdg_popup.repositioned event. The new popup position will not take
+ * effect until the corresponding configure event is acknowledged by the
+ * client. See xdg_popup.repositioned for details. The token itself is
+ * opaque, and has no other special meaning.
+ *
+ * If multiple reposition requests are sent, the compositor may skip all
+ * but the last one.
+ *
+ * If the popup is repositioned in response to a configure event for its
+ * parent, the client should send an xdg_positioner.set_parent_configure
+ * and possibly an xdg_positioner.set_parent_size request to allow the
+ * compositor to properly constrain the popup.
+ *
+ * If the popup is repositioned together with a parent that is being
+ * resized, but not in response to a configure event, the client should
+ * send an xdg_positioner.set_parent_size request.
+ */
+static inline void
+xdg_popup_reposition(struct xdg_popup *xdg_popup, struct xdg_positioner *positioner, uint32_t token)
+{
+	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
+			 XDG_POPUP_REPOSITION, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), 0, positioner, token);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/cmd/devdraw/wayland.c b/src/cmd/devdraw/wayland.c
new file mode 100644
index 00000000..0b13cf65
--- /dev/null
+++ b/src/cmd/devdraw/wayland.c
@@ -0,0 +1,1232 @@
+#include <u.h>
+#include <libc.h>
+#include <draw.h>
+#include <memdraw.h>
+#include <memlayer.h>
+#include <keyboard.h>
+#include <mouse.h>
+#include <cursor.h>
+#include <thread.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/input-event-codes.h>
+#include <wayland-client.h>
+#include <xkbcommon/xkbcommon.h>
+
+#include "bigarrow.h"
+#include "devdraw.h"
+#include "wayland-pointer-constraints.h"
+#include "wayland-xdg-decoration.h"
+#include "wayland-xdg-shell.h"
+
+// alt+click and ctl+click are mapped to mouse buttons
+// to support single button mice.
+#define ALT_BUTTON 1
+#define CTL_BUTTON 2
+
+struct WaylandBuffer {
+	int w;
+	int h;
+	int size;
+	char *data;
+	struct wl_buffer* wl_buffer;
+};
+typedef struct WaylandBuffer WaylandBuffer;
+
+struct WaylandClient {
+	// The screen image written to by the client, and read by this driver.
+	Memimage *memimage;
+
+	// The current mouse coordinates and a bitmask of held buttons.
+	int mouse_x;
+	int mouse_y;
+	int buttons;
+
+	// Booleans indicating whether control or alt are currently held.
+	int ctl;
+	int alt;
+
+	// State for key repeat for keyboard keys.
+	int repeat_rune;
+	int repeat_start_ms;
+
+	// Key repeat configuration. Can be changed by
+	// wl_surface_repeat_info events.
+	int repeat_interval_ms;
+	int repeat_delay_ms;
+
+	// State for "key repeat" for the mouse scroll wheel.
+	// This allows touchpad devices to have accelerated scrolling.
+	int repeat_scroll_button;
+	int repeat_scroll_count;
+	int repeat_scroll_rate_ms;
+	int repeat_scroll_next_ms;
+
+	// The Wayland surface for this window
+	// and its corresponding xdg objects.
+	struct wl_surface *wl_surface;
+	struct xdg_surface *xdg_surface;
+	struct xdg_toplevel *xdg_toplevel;
+
+	// Initial configure call is complete
+	int configured;
+
+	// These are called each frame while the key is pressed
+	// or scrolling is active, to implement key repeat and
+	// inertial scrolling.
+	struct wl_callback *wl_key_repeat_callback;
+	struct wl_callback *wl_scroll_repeat_callback;
+
+	// The mouse pointer and the surface for the current cursor.
+	struct wl_pointer *wl_pointer;
+	struct wl_surface *wl_surface_cursor;
+
+	// The keyboard and xkb state used
+	// for mapping scan codes to key codes.
+	struct wl_keyboard *wl_keyboard;
+	struct xkb_context *xkb_context;
+	struct xkb_keymap *xkb_keymap;
+	struct xkb_state *xkb_state;
+};
+typedef struct WaylandClient WaylandClient;
+
+static QLock wayland_lock;
+
+// Required globals wayland objects.
+static struct wl_display *wl_display;
+static struct wl_output *wl_output;
+static struct wl_registry *wl_registry;
+static struct wl_shm *wl_shm;
+static struct wl_compositor *wl_compositor;
+static struct xdg_wm_base *xdg_wm_base;
+static struct wl_seat *wl_seat;
+static struct wl_data_device_manager *wl_data_device_manager;
+static struct wl_data_device *wl_data_device;
+
+static char *snarf;
+uint32_t keyboard_enter_serial;
+
+// Optional global wayland objects.
+// Need to NULL check them before using.
+static struct zxdg_decoration_manager_v1 *decoration_manager;
+static struct zwp_pointer_constraints_v1 *pointer_constraints;
+
+// The wl output scale factor reported by wl_output.
+// We only set it if we get th event before entering the graphics loop.
+// Once we enter the loop, we never change it to avoid the need
+// to reason about which scale a buffer was created with.
+int wl_output_scale_factor = 1;
+int entered_gfx_loop = 0;
+
+// The delay in ms which a key must be held to begin repeating..
+int key_repeat_delay_ms = 500;
+// The number of ms between repeats of a repeating key.
+int key_repeat_ms = 100;
+// The maximum number of ms between repeats of a scroll.
+// This is scaled by the number of repeating scrolls pending.
+int scroll_repeat_ms = 100;
+
+// A pool of xrgb888 buffers used for drawing to the screen.
+// When drawing, we give ownership of the buffer's memory to the compositor.
+// The compositor notifies us asynchronously when it is done reading the buffer.
+// In the case that we need to draw (rpc_flush) before the buffer is ready,
+// we will need to allocate a whole new buffer to draw to.
+// We use this pool to avoid the need to setup a new shared memory buffer
+// each time this happens.
+#define N_XRGB8888_BUFFERS 3
+struct WaylandBuffer *xrgb8888_buffers[N_XRGB8888_BUFFERS];
+
+int wayland_debug = 0;
+
+#define DEBUG(...)					\
+do {								\
+	if (wayland_debug) {			\
+		fprint(2, __VA_ARGS__);	\
+	}							\
+} while(0)
+
+static void registry_global(void *data, struct wl_registry *wl_registry,
+	uint32_t name, const char *interface, uint32_t version) {
+	if (strcmp(interface, wl_output_interface.name) == 0) {
+		wl_output = wl_registry_bind(wl_registry, name, &wl_output_interface, 2);
+
+	} else if (strcmp(interface, wl_shm_interface.name) == 0) {
+		wl_shm = wl_registry_bind(wl_registry, name, &wl_shm_interface, 1);
+
+	} else if (strcmp(interface, wl_compositor_interface.name) == 0) {
+		wl_compositor = wl_registry_bind(wl_registry, name,
+			&wl_compositor_interface, 4);
+
+	} else if (strcmp(interface, xdg_wm_base_interface.name) == 0) {
+		xdg_wm_base = wl_registry_bind(wl_registry, name,
+			&xdg_wm_base_interface, 1);
+
+	} else if (strcmp(interface, wl_seat_interface.name) == 0) {
+		wl_seat = wl_registry_bind(wl_registry, name, &wl_seat_interface, 4);
+
+	} else if (strcmp(interface, wl_data_device_manager_interface.name) == 0) {
+		wl_data_device_manager = wl_registry_bind(wl_registry, name, &wl_data_device_manager_interface, 2);
+
+	} else if (strcmp(interface, zxdg_decoration_manager_v1_interface.name) == 0) {
+		decoration_manager = wl_registry_bind(wl_registry, name,
+			&zxdg_decoration_manager_v1_interface, 1);
+
+	} else if (strcmp(interface, zwp_pointer_constraints_v1_interface.name) == 0) {
+		pointer_constraints = wl_registry_bind(wl_registry, name,
+			&zwp_pointer_constraints_v1_interface, 1);
+	}
+}
+
+static void registry_global_remove(void *data, struct wl_registry *wl_registry,
+	uint32_t name) {}
+
+static const struct wl_registry_listener wl_registry_listener = {
+	.global = registry_global,
+	.global_remove = registry_global_remove,
+};
+
+void wl_output_geometry(void *data, struct wl_output *wl_output,
+	int32_t x, int32_t y, int32_t physical_width, int32_t physical_height,
+	int32_t subpixel, const char *make, const char *model, int32_t transform) {}
+
+void wl_output_mode(void *data, struct wl_output *wl_output, uint32_t flags,
+	int32_t width, int32_t height, int32_t refresh) {}
+
+void wl_output_done(void *data, struct wl_output *wl_output) {}
+
+void wl_output_scale(void *data, struct wl_output *wl_output, int32_t factor) {
+	DEBUG("wl_output_scale(factor=%d)\n", factor);
+
+	qlock(&wayland_lock);
+
+	if (!entered_gfx_loop) {
+		wl_output_scale_factor = factor;
+	}
+
+	qunlock(&wayland_lock);
+}
+
+static const struct wl_output_listener wl_output_listener = {
+	.geometry = wl_output_geometry,
+	.mode = wl_output_mode,
+	.done = wl_output_done,
+	.scale = wl_output_scale,
+};
+
+static void xdg_wm_base_ping(void *data, struct xdg_wm_base *xdg_wm_base, uint32_t serial) {
+	xdg_wm_base_pong(xdg_wm_base, serial);
+}
+
+static const struct xdg_wm_base_listener xdg_wm_base_listener = {
+	.ping = xdg_wm_base_ping,
+};
+
+void wl_data_device_listener_data_offer(void *data,
+	struct wl_data_device *wl_data_device, struct wl_data_offer *id) {}
+
+void wl_data_device_listener_data_enter(void *data,
+	struct wl_data_device *wl_data_device, uint32_t serial,
+	struct wl_surface *surface, wl_fixed_t x, wl_fixed_t y,
+	struct wl_data_offer *id) {}
+
+void wl_data_device_listener_data_leave(void *data,
+	struct wl_data_device *wl_data_device) {}
+
+void wl_data_device_listener_data_motion(void *data,
+	struct wl_data_device *wl_data_device, uint32_t time,
+	wl_fixed_t x, wl_fixed_t y) {}
+
+void wl_data_device_listener_data_drop(void *data,
+	struct wl_data_device *wl_data_device) {}
+
+void wl_data_device_listener_selection(void *data,
+	struct wl_data_device *wl_data_device, struct wl_data_offer *id) {
+	DEBUG("wl_data_device_listener_selection\n");
+
+	if (id == NULL) {
+		qlock(&wayland_lock);
+		free(snarf);
+		snarf = NULL;
+		qunlock(&wayland_lock);
+		DEBUG("wl_data_device_listener_selection: no data\n");
+		return;
+	}
+
+	int fds[2];
+	if (pipe(fds) < 0) {
+		sysfatal("Failed to create pipe");
+	}
+	wl_data_offer_receive(id, "text/plain", fds[1]);
+	close(fds[1]);
+	wl_display_roundtrip(wl_display);
+
+	qlock(&wayland_lock);
+
+	int total = 0;
+	snarf = NULL;
+	for (; ;) {
+		char buf[128];
+		int n = read(fds[0], &buf, sizeof(buf));
+		if (n < 0 && errno == EAGAIN) {
+			continue;
+		}
+		if (n < 0) {
+			sysfatal("Read failed");
+		}
+		if (n == 0) {
+			break;
+		}
+		// +1 to ensure it's always at least null terminated.
+		char *tmp = calloc(1, total + n + 1);
+		if (snarf != NULL) {
+			strncpy(tmp, snarf, total);
+		}
+		memcpy(tmp+total, buf, n);
+		total += n;
+		snarf = tmp;
+	}
+
+	DEBUG("wl_data_device_listener_selection: read [%s]\n", snarf);
+	qunlock(&wayland_lock);
+	close(fds[0]);
+}
+
+static const struct wl_data_device_listener wl_data_device_listener = {
+	.data_offer = wl_data_device_listener_data_offer,
+	.enter = wl_data_device_listener_data_enter,
+	.leave = wl_data_device_listener_data_leave,
+	.motion = wl_data_device_listener_data_motion,
+	.drop = wl_data_device_listener_data_drop,
+	.selection = wl_data_device_listener_selection,
+};
+
+void wl_data_source_target(void *data,
+	struct wl_data_source *wl_data_source,
+	const char *mime_type) {}
+
+void wl_data_source_send(void *data,
+	struct wl_data_source *wl_data_source,
+	const char *mime_type, int32_t fd) {
+	DEBUG("wl_data_source_send(mime_type=%s)\n", mime_type);
+
+	if (strcmp(mime_type, "text/plain") != 0) {
+		DEBUG("unknown mime type\n");
+		close(fd);
+		return;
+	}
+
+	qlock(&wayland_lock);
+
+	int total = 0;
+	if (snarf != NULL) {
+		total = strlen(snarf);
+	}
+	DEBUG("wl_data_source_send: writing %d bytes\n", total);
+	char *p = snarf;
+	while (total > 0) {
+		int n = write(fd, p, total);
+		if (n < 0 && errno == EAGAIN) {
+			continue;
+		}
+		if (n < 0) {
+			sysfatal("Write error");
+		}
+		p += n;
+		total -= n;
+	}
+
+	qunlock(&wayland_lock);
+	close(fd);
+}
+
+void wl_data_source_cancelled(void *data, struct wl_data_source *wl_data_source) {}
+
+static const struct wl_data_source_listener wl_data_source_listener = {
+	.target = wl_data_source_target,
+	.send = wl_data_source_send,
+	.cancelled = wl_data_source_cancelled,
+};
+
+void delete_buffer(WaylandBuffer *b) {
+	munmap(b->data, b->size);
+	wl_buffer_destroy(b->wl_buffer);
+	free(b);
+}
+
+static void wl_buffer_release(void *data, struct wl_buffer *wl_buffer) {
+	if (data == NULL) {
+		wl_buffer_destroy(wl_buffer);
+		return;
+	}
+	for (int i = 0; i < N_XRGB8888_BUFFERS; i++) {
+		if (xrgb8888_buffers[i] == NULL) {
+			xrgb8888_buffers[i] = (WaylandBuffer*) data;
+			return;
+		}
+	}
+	delete_buffer((WaylandBuffer*) data);
+}
+
+static const struct wl_buffer_listener wl_buffer_listener = {
+	.release = wl_buffer_release,
+};
+
+static void xdg_surface_configure(void *data, struct xdg_surface *xdg_surface, uint32_t serial) {
+	DEBUG("xdg_surface_configure\n");
+	const Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	xdg_surface_ack_configure(wl->xdg_surface, serial);
+	wl->configured = 1;
+
+	qunlock(&wayland_lock);
+	DEBUG("xdg_surface_configure: returned\n");
+}
+
+static const struct xdg_surface_listener xdg_surface_listener = {
+	.configure = xdg_surface_configure,
+};
+
+void xdg_toplevel_configure(void *data, struct xdg_toplevel *xdg_toplevel,
+	int32_t width, int32_t height, struct wl_array *states) {
+	DEBUG("xdg_toplevel_configure(width=%d, height=%d)\n", width, height);
+	if (width == 0 || height == 0) {
+		return;
+	}
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	width *= wl_output_scale_factor;
+	height *= wl_output_scale_factor;
+	Rectangle r = Rect(0, 0, width, height);
+	if (eqrect(r, wl->memimage->r)) {
+		// The size didn't change, so nothing to do.
+		qunlock(&wayland_lock);
+		return;
+	}
+
+	// The size changed, so allocate a new Memimage and notify the client.
+	wl->memimage = _allocmemimage(r, XRGB32);
+	c->mouserect = r;
+
+	qunlock(&wayland_lock);
+	gfx_replacescreenimage(c, wl->memimage);
+}
+
+void xdg_toplevel_close(void *data, struct xdg_toplevel *xdg_toplevel) {
+	DEBUG("xdg_toplevel_close\n");
+	threadexitsall(nil);
+}
+
+static const struct xdg_toplevel_listener xdg_toplevel_listener = {
+	.configure = xdg_toplevel_configure,
+	.close = xdg_toplevel_close,
+};
+
+static const struct wl_callback_listener wl_callback_key_repeat_listener;
+
+static void wl_callback_key_repeat(void *data, struct wl_callback *wl_callback, uint32_t time) {
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	wl_callback_destroy(wl_callback);
+
+	qlock(&wayland_lock);
+
+	int repetitions = 0;
+	int repeat_rune = wl->repeat_rune;
+
+	if (wl->repeat_interval_ms == 0 || wl->repeat_rune == 0) {
+		goto done;
+	}
+
+	int dt = time - wl->repeat_start_ms;
+
+	// There is an initial delay for repetition to start, so
+	// repeat_start_ms can be in the future.
+	if (wl->repeat_start_ms < time && wl->repeat_interval_ms <= dt) {
+		repetitions = dt / wl->repeat_interval_ms;
+
+		// Incrementing this way, rather than setting start to now,
+		// avoids losing fractional time to integer division.
+		wl->repeat_start_ms += repetitions * wl->repeat_interval_ms;
+	}
+
+	wl_callback = wl_surface_frame(wl->wl_surface);
+	wl_callback_add_listener(wl_callback, &wl_callback_key_repeat_listener, c);
+	wl_surface_commit(wl->wl_surface);
+
+done:
+	qunlock(&wayland_lock);
+	for(int i = 0; i < repetitions; i++) {
+		gfx_keystroke(c, repeat_rune);
+	}
+}
+
+static const struct wl_callback_listener wl_callback_key_repeat_listener = {
+	.done = wl_callback_key_repeat,
+};
+
+static const struct wl_callback_listener wl_callback_scroll_listener;
+
+static void wl_callback_scroll_repeat(void *data, struct wl_callback *wl_callback, uint32_t time) {
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+
+	wl_callback_destroy(wl_callback);
+	qlock(&wayland_lock);
+
+	int x = wl->mouse_x;
+	int y = wl->mouse_y;
+	int repeat_scroll_button = 0;
+	if (wl->repeat_scroll_button && time >= wl->repeat_scroll_next_ms) {
+		repeat_scroll_button = wl->repeat_scroll_button | wl->buttons;
+		wl->repeat_scroll_count--;
+		if (wl->repeat_scroll_count == 0) {
+			wl->repeat_scroll_button = 0;
+		} else {
+			wl->repeat_scroll_next_ms = time + scroll_repeat_ms/wl->repeat_scroll_count;
+		}
+	}
+
+	if (wl->repeat_scroll_count > 0) {
+		wl_callback = wl_surface_frame(wl->wl_surface);
+		wl_callback_add_listener(wl_callback, &wl_callback_scroll_listener, c);
+		wl_surface_commit(wl->wl_surface);
+	}
+	qunlock(&wayland_lock);
+
+	if (repeat_scroll_button) {
+		gfx_mousetrack(c, x, y, repeat_scroll_button, (uint) time);
+	}
+}
+
+static const struct wl_callback_listener wl_callback_scroll_listener = {
+	.done = wl_callback_scroll_repeat,
+};
+
+void wl_pointer_enter(void *data,struct wl_pointer *wl_pointer, uint32_t serial,
+	struct wl_surface *surface, wl_fixed_t surface_x, wl_fixed_t surface_y) {
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	wl->mouse_x = wl_fixed_to_int(surface_x) * wl_output_scale_factor;
+	wl->mouse_y = wl_fixed_to_int(surface_y) * wl_output_scale_factor;
+
+	wl_pointer_set_cursor(wl->wl_pointer, serial, wl->wl_surface_cursor, 0, 0);
+
+	qunlock(&wayland_lock);
+	// We don't call gfx_mousetrack here, since we don't have the time.
+}
+
+void wl_pointer_leave(void *data, struct wl_pointer *wl_pointer,
+	uint32_t serial, struct wl_surface *surface) {
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	wl->buttons = 0;
+	wl->repeat_scroll_button = 0;
+
+	qunlock(&wayland_lock);
+}
+
+void wl_pointer_motion(void *data, struct wl_pointer *wl_pointer, uint32_t time,
+	wl_fixed_t surface_x, wl_fixed_t surface_y){
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	wl->repeat_scroll_button = 0;
+	wl->repeat_scroll_count = 0;
+	wl->mouse_x = wl_fixed_to_int(surface_x) * wl_output_scale_factor;
+	wl->mouse_y = wl_fixed_to_int(surface_y) * wl_output_scale_factor;
+	int x = wl->mouse_x;
+	int y = wl->mouse_y;
+	int b = wl->buttons;
+
+	qunlock(&wayland_lock);
+	gfx_mousetrack(c, x, y, b, (uint) time);
+}
+
+void wl_pointer_button(void *data, struct wl_pointer *wl_pointer, uint32_t serial,
+	uint32_t time, uint32_t button, uint32_t state) {
+	DEBUG("wl_pointer_button(button=%d)\n", (int) button);
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	wl->repeat_scroll_button = 0;
+	wl->repeat_scroll_count = 0;
+
+	int mask = 0;
+	switch (button) {
+	case BTN_LEFT:
+		mask = 1<<0;
+		break;
+	case BTN_MIDDLE:
+		mask = 1<<1;
+		break;
+	case BTN_RIGHT:
+		mask = 1<<2;
+		break;
+	case BTN_4:
+		mask = 1<<3;
+		break;
+	case BTN_5:
+		mask = 1<<4;
+		break;
+	default:
+		DEBUG("wl_pointer_button: unknown button: %d\n", button);
+		qunlock(&wayland_lock);
+		return;
+	}
+	if (button == BTN_LEFT) {
+		if (wl->ctl) {
+			mask = 1 << CTL_BUTTON;
+		} else if (wl->alt) {
+			mask = 1 << ALT_BUTTON;
+		}
+	}
+	DEBUG("wl_pointer_button: mask=%x\n", mask);
+
+	switch (state) {
+	case WL_POINTER_BUTTON_STATE_PRESSED:
+		wl->buttons |= mask;
+		break;
+	case WL_POINTER_BUTTON_STATE_RELEASED:
+		wl->buttons &= ~mask;
+		break;
+	default:
+		fprint(2, "Unknown button state: %d\n", state);
+	}
+	int x = wl->mouse_x;
+	int y = wl->mouse_y;
+	int b = wl->buttons;
+
+	qunlock(&wayland_lock);
+	DEBUG("wl_pointer_button: gfx_trackmouse(x=%d, y=%d, b=%d)\n", x, y, b);
+	gfx_mousetrack(c, x, y, b, (uint) time);
+}
+
+void wl_pointer_axis(void *data, struct wl_pointer *wl_pointer, uint32_t time,
+	uint32_t axis, wl_fixed_t value_fixed) {
+	double value = wl_fixed_to_double(value_fixed);
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	int x = wl->mouse_x;
+	int y = wl->mouse_y;
+	wl->repeat_scroll_button = 0;
+	wl->repeat_scroll_count = 0;
+
+	int b = 0;
+	if (value < 0) {
+		b |= 1 << 3;
+	} else if (value > 0) {
+		b |= 1 << 4;
+	}
+	int mag = fabs(value);
+	if (mag > 1) {
+		wl->repeat_scroll_button = b;
+		wl->repeat_scroll_count = mag;
+		wl->repeat_scroll_next_ms = time + scroll_repeat_ms/wl->repeat_scroll_count;
+		wl->wl_scroll_repeat_callback = wl_surface_frame(wl->wl_surface);
+		wl_callback_add_listener(wl->wl_scroll_repeat_callback,
+				&wl_callback_scroll_listener, c);
+	}
+	b |= wl->buttons;
+
+	qunlock(&wayland_lock);
+	gfx_mousetrack(c, x, y, b, (uint) time);
+}
+
+
+static const struct wl_pointer_listener pointer_listener = {
+	.enter = wl_pointer_enter,
+	.leave = wl_pointer_leave,
+	.motion = wl_pointer_motion,
+	.button = wl_pointer_button,
+	.axis = wl_pointer_axis,
+};
+
+void wl_keyboard_keymap(void *data, struct wl_keyboard *wl_keyboard,
+	uint32_t format, int32_t fd, uint32_t size) {
+	DEBUG("wl_keyboard_keymap(format=%d, fd=%d, size=%d)\n", format, fd, size);
+	char *keymap = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (keymap == MAP_FAILED) {
+		DEBUG("wl_keyboard_keymap: %s", strerror(errno));
+		return;
+	}
+
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	if (wl->xkb_keymap != NULL) {
+		xkb_keymap_unref(wl->xkb_keymap);
+	}
+	wl->xkb_keymap = xkb_keymap_new_from_string(wl->xkb_context, keymap,
+		XKB_KEYMAP_FORMAT_TEXT_V1,
+		XKB_KEYMAP_COMPILE_NO_FLAGS);
+
+	if (wl->xkb_state != NULL) {
+		xkb_state_unref(wl->xkb_state);
+	}
+	wl->xkb_state = xkb_state_new(wl->xkb_keymap);
+
+	qunlock(&wayland_lock);
+    	munmap(keymap, size);
+	close(fd);
+}
+
+void wl_keyboard_enter(void *data, struct wl_keyboard *wl_keyboard,
+	uint32_t serial, struct wl_surface *surface, struct wl_array *keys) {
+	DEBUG("wl_keyboard_enter\n");
+	qlock(&wayland_lock);
+	keyboard_enter_serial = serial;
+	qunlock(&wayland_lock);
+}
+
+void wl_keyboard_leave(void *data, struct wl_keyboard *wl_keyboard,
+	uint32_t serial, struct wl_surface *surface) {
+	DEBUG("wl_keyboard_leave\n");
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	wl->ctl = 0;
+	wl->alt = 0;
+	wl->repeat_rune = 0;
+
+	qunlock(&wayland_lock);
+}
+
+void wl_keyboard_key(void *data, struct wl_keyboard *wl_keyboard,
+	uint32_t serial, uint32_t time, uint32_t key, uint32_t state) {
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	wl->repeat_rune = 0;
+	wl->repeat_scroll_button = 0;
+	wl->repeat_scroll_count = 0;
+
+	key += 8;	// Add 8 to translate Linux scan code to xkb code.
+	uint32_t rune = xkb_state_key_get_utf32(wl->xkb_state, key);
+	xkb_keysym_t keysym = xkb_state_key_get_one_sym(wl->xkb_state, key);
+
+	if (wayland_debug) {
+		char name[256];
+		xkb_keysym_get_name(keysym, &name[0], 256);
+		char *state_str = WL_KEYBOARD_KEY_STATE_PRESSED ? "down" : "up";
+		DEBUG("wl_keyboard_key: keysym=%s, rune=0x%x, state=%s\n",
+			name, rune, state_str);
+	}
+
+	switch (keysym) {
+	case XKB_KEY_Return:
+		rune = '\n';
+		break;
+	case XKB_KEY_Alt_L:
+	case XKB_KEY_Alt_R:
+		rune = Kalt;
+		if (state == WL_KEYBOARD_KEY_STATE_PRESSED) {
+			wl->alt = 1;
+		} else {
+			wl->alt = 0;
+		}
+		if (wl->buttons) {
+			if (state == WL_KEYBOARD_KEY_STATE_PRESSED) {
+				wl->buttons |= 1 << ALT_BUTTON;
+			} else {
+				wl->buttons &= ~(1 << ALT_BUTTON);
+			}
+			int x = wl->mouse_x;
+			int y = wl->mouse_y;
+			int b = wl->buttons;
+
+			qunlock(&wayland_lock);
+			gfx_mousetrack(c, x, y, b, (uint) time);
+			return;
+		}
+		break;
+	case XKB_KEY_Control_L:
+	case XKB_KEY_Control_R:
+		// For some reason, Kctl is not used;
+		// it results in drawing a replacement character.
+		// Common ctl combos still work.
+		// For example ctl+w sends rune 0x17
+		// which erases the previous word.
+		rune = 0; // Kctl;
+		if (state == WL_KEYBOARD_KEY_STATE_PRESSED) {
+			wl->ctl = 1;
+		} else {
+			wl->ctl = 0;
+		}
+		if (wl->buttons) {
+			if (state == WL_KEYBOARD_KEY_STATE_PRESSED) {
+				wl->buttons |= 1 << CTL_BUTTON;
+			} else {
+				wl->buttons &= ~(1 << CTL_BUTTON);
+			}
+			int x = wl->mouse_x;
+			int y = wl->mouse_y;
+			int b = wl->buttons;
+
+			qunlock(&wayland_lock);
+			gfx_mousetrack(c, x, y, b, (uint) time);
+			return;
+		}
+		break;
+	case XKB_KEY_Delete:
+		rune = Kdel;
+		break;
+	case XKB_KEY_Escape:
+		rune = Kesc;
+		break;
+	case XKB_KEY_Home:
+		rune = Khome;
+		break;
+	case XKB_KEY_End:
+		rune = Kend;
+		break;
+	case XKB_KEY_Prior:
+		rune = Kpgup;
+		break;
+	case XKB_KEY_Next:
+		rune = Kpgdown;
+		break;
+	case XKB_KEY_Up:
+		rune = Kup;
+		break;
+	case XKB_KEY_Down:
+		rune = Kdown;
+		break;
+	case XKB_KEY_Left:
+		rune = Kleft;
+		break;
+	case XKB_KEY_Right:
+		rune = Kright;
+		break;
+	}
+
+	if (wl->repeat_interval_ms && state == WL_KEYBOARD_KEY_STATE_PRESSED && rune != 0) {
+		wl->repeat_rune = rune;
+		wl->repeat_start_ms = time + wl->repeat_delay_ms;
+		wl->wl_key_repeat_callback = wl_surface_frame(wl->wl_surface);
+		wl_callback_add_listener(wl->wl_key_repeat_callback,
+				&wl_callback_key_repeat_listener, c);
+	}
+	qunlock(&wayland_lock);
+	if (state == WL_KEYBOARD_KEY_STATE_PRESSED && rune != 0)
+		gfx_keystroke(c, rune);
+}
+
+void wl_keyboard_modifiers(void *data, struct wl_keyboard *wl_keyboard,
+	uint32_t serial, uint32_t mods_depressed, uint32_t mods_latched,
+	uint32_t mods_locked, uint32_t group) {
+	DEBUG("wl_keyboard_modifiers\n");
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	xkb_state_update_mask(wl->xkb_state, mods_depressed,
+		mods_latched, mods_locked, 0, 0, group);
+
+	qunlock(&wayland_lock);
+}
+
+void wl_keyboard_repeat_info(void *data, struct wl_keyboard *wl_keyboard,
+	int32_t rate, int32_t delay) {
+	DEBUG("wl_keyboard_repeat_info(rate=%d, delay=%d)\n",
+		(int) rate, (int) delay);
+	Client* c = data;
+	WaylandClient *wl = (WaylandClient*) c->view;
+	int interval = 0;
+
+	// rate is in keystrokes per second. Capping to 1k simplifies
+	// the code.
+	rate = rate > 1000 ? 1000 : rate;
+	if (rate > 0)
+		interval = 1000 / rate;
+
+	qlock(&wayland_lock);
+	wl->repeat_interval_ms = interval;
+	wl->repeat_delay_ms = delay;
+	qunlock(&wayland_lock);
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+	.keymap = wl_keyboard_keymap,
+	.enter = wl_keyboard_enter,
+	.leave = wl_keyboard_leave,
+	.key = wl_keyboard_key,
+	.modifiers = wl_keyboard_modifiers,
+	.repeat_info = wl_keyboard_repeat_info,
+};
+
+void	gfx_main(void) {
+	DEBUG("gfx_main called\n");
+
+	wl_display = wl_display_connect(NULL);
+	wl_registry = wl_display_get_registry(wl_display);
+	wl_registry_add_listener(wl_registry, &wl_registry_listener, NULL);
+	wl_display_roundtrip(wl_display);
+
+	// Ensure required globals were correctly bound.
+	if (wl_display == NULL) {
+		sysfatal("Unable to get Wayland display");
+	}
+	if (wl_registry == NULL) {
+		sysfatal("Unable to get Wayland registry");
+	}
+	if (wl_output == NULL) {
+		sysfatal("Unable to bind wl_output");
+	}
+	if (wl_shm == NULL) {
+		sysfatal("Unable to bind wl_shm");
+	}
+	if (wl_compositor == NULL) {
+		sysfatal("Unable to bind wl_compositor");
+	}
+	if (xdg_wm_base == NULL) {
+		sysfatal("Unable to bind xdg_wm_base");
+	}
+	if (wl_seat == NULL) {
+		sysfatal("Unable to bind wl_seat");
+	}
+	if (wl_data_device_manager == NULL) {
+		sysfatal("Unable to bind wl_data_device_manager");
+	}
+	wl_output_add_listener(wl_output, &wl_output_listener, NULL);
+	xdg_wm_base_add_listener(xdg_wm_base, &xdg_wm_base_listener, NULL);
+	wl_data_device = wl_data_device_manager_get_data_device(
+		wl_data_device_manager, wl_seat);
+	wl_data_device_add_listener(wl_data_device, &wl_data_device_listener, NULL);
+	wl_display_roundtrip(wl_display);
+
+	entered_gfx_loop = 1;
+	gfx_started();
+	DEBUG("gfx_main: entering loop\n");
+	while (wl_display_dispatch(wl_display) > 0 || errno == EAGAIN)
+		;
+	sysfatal("wl_display_dispatch: %r");
+}
+
+static void rpc_resizeimg(Client*) {
+	DEBUG("rpc_resizeimg\n");
+}
+
+static void rpc_resizewindow(Client*, Rectangle) {
+	DEBUG("rpc_resizewindow\n");
+}
+
+static int next_shm = 0;
+
+WaylandBuffer *new_buffer(int w, int h, int format) {
+	int stride = w * 4;
+	int size = stride * h;
+
+	// Create an anonymous shared memory file.
+	char name[128];
+	snprintf(name, 128, "/acme_wl_shm-%d-%d", getpid(), next_shm++);
+	int fd = shm_open(name, O_RDWR | O_CREAT | O_EXCL, 0600);
+	if (fd < 0) {
+		sysfatal("shm_open failed");
+	}
+	shm_unlink(name);
+
+	// Set the file's size.
+	int ret;
+	do {
+		ret = ftruncate(fd, size);
+	} while (ret < 0 && errno == EINTR);
+	if (ret < 0) {
+		sysfatal("ftruncate failed");
+	}
+
+	char *d = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+	if (d == MAP_FAILED) {
+		sysfatal("mmap failed");
+	}
+
+	WaylandBuffer *b = malloc(sizeof(WaylandBuffer));
+	b->w = w;
+	b->h = h;
+	b->size = size;
+	b->data = d;
+	struct wl_shm_pool *p = wl_shm_create_pool(wl_shm, fd, size);
+	b->wl_buffer = wl_shm_pool_create_buffer(p, 0, w, h, stride, format);
+	wl_shm_pool_destroy(p);
+	close(fd);
+	return b;
+}
+
+void wayland_set_cursor(WaylandClient *wl, Cursor *cursor) {
+	// Convert bitmap to ARGB.
+	// Yes, this is super clunky. Sorry about that.
+	const uint32_t fg = 0xFF000000;
+	const uint32_t a = 0x00FFFFFF;
+	uint32_t data[8*32];
+	int j = 0;
+	for (int i = 0; i < 32; i++) {
+		char c = cursor->set[i];
+		data[j++] = (c >>7) & 1 == 1 ? fg : a;
+		data[j++] = (c >> 6) & 1 == 1 ? fg : a;
+		data[j++] = (c >> 5) & 1 == 1 ? fg : a;
+		data[j++] = (c >> 4) & 1 == 1 ? fg : a;
+		data[j++] = (c >> 3) & 1 == 1 ? fg : a;
+		data[j++] = (c >> 2) & 1 == 1 ? fg : a;
+		data[j++] = (c >> 1) & 1 == 1 ? fg : a;
+		data[j++] = (c >> 0) & 1 == 1 ? fg : a;
+	}
+
+	WaylandBuffer *b = new_buffer(16, 16, WL_SHM_FORMAT_ARGB8888);
+	memcpy(b->data, (char*) &data[0], b->size);
+
+	// We don't want to bother saving this buffer in xrgb8888_buffers.
+	// Unmap and use NULL for it's listener data.
+	// This will cause it to be destroyed when it is released.
+	munmap(b->data, b->size);
+	wl_buffer_add_listener(b->wl_buffer, &wl_buffer_listener, NULL);
+
+	wl_surface_attach(wl->wl_surface_cursor, b->wl_buffer, 0, 0);
+	wl_surface_damage_buffer(wl->wl_surface_cursor, 0, 0, 16, 16);
+	wl_surface_commit(wl->wl_surface_cursor);
+}
+
+static void rpc_setcursor(Client *c, Cursor *cursor, Cursor2*) {
+	DEBUG("rpc_setcursor\n");
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	if (cursor == NULL) {
+		cursor = &bigarrow;
+	}
+	wayland_set_cursor(wl, cursor);
+
+	qunlock(&wayland_lock);
+}
+
+static void rpc_setlabel(Client *c, char *label) {
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	xdg_toplevel_set_title(wl->xdg_toplevel, label);
+
+	qunlock(&wayland_lock);
+}
+
+static void rpc_setmouse(Client *c, Point p) {
+	if (pointer_constraints == NULL) {
+		// If there is no pointer constraints extension,
+		// we cannot warp the mouse.
+		return;
+	}
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	// Wayland does not directly support warping the pointer.
+	// Instead, we use (misuse?) the pointer constraints extension,
+	// which allows sending the compositor a new pointer location
+	// hint when the pointer is unlocked.
+	// We lock the pointer, and immediately unlock it with a hint
+	// of the desired wrap location.
+
+	struct zwp_locked_pointer_v1 *lock = zwp_pointer_constraints_v1_lock_pointer(
+		pointer_constraints, wl->wl_surface, wl->wl_pointer, NULL,
+		ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+	int x = wl_fixed_from_int(p.x / wl_output_scale_factor);
+	int y = wl_fixed_from_int(p.y / wl_output_scale_factor);
+	zwp_locked_pointer_v1_set_cursor_position_hint(lock, x, y);
+	wl_surface_commit(wl->wl_surface);
+	zwp_locked_pointer_v1_destroy(lock);
+
+	wl->mouse_x = wl_fixed_to_int(x) * wl_output_scale_factor;
+	wl->mouse_y = wl_fixed_to_int(y) * wl_output_scale_factor;
+
+	int mx = wl->mouse_x;
+	int my = wl->mouse_y;
+	int mb = wl->buttons;
+
+	qunlock(&wayland_lock);
+	gfx_mousetrack(c, mx, my, mb, nsec()/1000000);
+}
+
+static void rpc_topwin(Client*) {
+	DEBUG("rpc_topwin\n");
+}
+
+static void rpc_bouncemouse(Client*, Mouse) {
+	DEBUG("rpc_bouncemouse\n");
+}
+
+// Must be called with the lock held.
+WaylandBuffer *get_xrgb8888_buffer(int w, int h) {
+	for (int i = 0; i < N_XRGB8888_BUFFERS; i++) {
+		if (xrgb8888_buffers[i] == NULL) {
+			continue;
+		}
+		// Delete any cached buffers that are not the right size.
+		if (xrgb8888_buffers[i]->w != w || xrgb8888_buffers[i]->h != h) {
+			delete_buffer(xrgb8888_buffers[i]);
+			xrgb8888_buffers[i] = NULL;
+			continue;
+		}
+		WaylandBuffer *b = xrgb8888_buffers[i];
+		xrgb8888_buffers[i] = NULL;
+		return b;
+	}
+	WaylandBuffer *b = new_buffer(w, h, WL_SHM_FORMAT_XRGB8888);
+	wl_buffer_add_listener(b->wl_buffer, &wl_buffer_listener, b);
+	return b;
+}
+
+static void rpc_flush(Client *c, Rectangle r) {
+	WaylandClient *wl = (WaylandClient*) c->view;
+	qlock(&wayland_lock);
+
+	if (wl->configured) {
+		int w = Dx(wl->memimage->r);
+		int h = Dy(wl->memimage->r);
+		WaylandBuffer *b = get_xrgb8888_buffer(w, h);
+		memcpy(b->data, (char*) wl->memimage->data->bdata, b->size);
+		wl_surface_attach(wl->wl_surface, b->wl_buffer, 0, 0);
+		wl_surface_damage_buffer(wl->wl_surface, r.min.x, r.min.y, Dx(r), Dy(r));
+		wl_surface_commit(wl->wl_surface);
+		wl_display_flush(wl_display);
+	}
+
+	qunlock(&wayland_lock);
+}
+
+static ClientImpl wayland_impl = {
+	rpc_resizeimg,
+	rpc_resizewindow,
+	rpc_setcursor,
+	rpc_setlabel,
+	rpc_setmouse,
+	rpc_topwin,
+	rpc_bouncemouse,
+	rpc_flush
+};
+
+Memimage *rpc_attach(Client *c, char *label, char *winsize) {
+	DEBUG("rpc_attach(%s)\n", label);
+
+	qlock(&wayland_lock);
+
+	WaylandClient *wl = calloc(1, sizeof(WaylandClient));
+	c->impl = &wayland_impl;
+	c->view = wl;
+
+	wl->repeat_interval_ms = key_repeat_ms;
+	wl->repeat_delay_ms = key_repeat_ms;
+	wl->wl_surface = wl_compositor_create_surface(wl_compositor);
+
+	wl->xdg_surface = xdg_wm_base_get_xdg_surface(xdg_wm_base, wl->wl_surface);
+	xdg_surface_add_listener(wl->xdg_surface, &xdg_surface_listener, c);
+
+	wl->xdg_toplevel = xdg_surface_get_toplevel(wl->xdg_surface);
+	xdg_toplevel_add_listener(wl->xdg_toplevel, &xdg_toplevel_listener, c);
+	xdg_toplevel_set_title(wl->xdg_toplevel, label);
+
+	wl->wl_pointer = wl_seat_get_pointer(wl_seat);
+	wl_pointer_add_listener(wl->wl_pointer, &pointer_listener, c);
+	wl->wl_surface_cursor = wl_compositor_create_surface(wl_compositor);
+	wayland_set_cursor(wl, &bigarrow);
+
+	wl->wl_keyboard = wl_seat_get_keyboard(wl_seat);
+	wl_keyboard_add_listener(wl->wl_keyboard, &keyboard_listener, c);
+	wl->xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+
+	// If the xdg decorations extension is available,
+	// enable server-side decorations.
+	// Otherwise there will be no window decorations
+	// (title, resize, buttons, etc.).
+	if (decoration_manager != NULL) {
+		struct zxdg_toplevel_decoration_v1 *d =
+			zxdg_decoration_manager_v1_get_toplevel_decoration(
+				decoration_manager, wl->xdg_toplevel);
+		zxdg_toplevel_decoration_v1_set_mode(d,
+			ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE);
+	}
+
+	// TODO: parse winsize.
+	int w = 640*wl_output_scale_factor;
+	int h = 480*wl_output_scale_factor;
+	Rectangle r = Rect(0, 0, w, h);
+	wl->memimage = _allocmemimage(r, XRGB32);
+	c->mouserect = r;
+	c->displaydpi = 110 * wl_output_scale_factor;
+	wl_surface_set_buffer_scale(wl->wl_surface, wl_output_scale_factor);
+	wl_surface_commit(wl->wl_surface);
+	wl_display_flush(wl_display);
+
+	qunlock(&wayland_lock);
+	return wl->memimage;
+}
+
+char *rpc_getsnarf(void) {
+	DEBUG("rpc_getsnarf\n");
+	qlock(&wayland_lock);
+
+	if (snarf == NULL) {
+		qunlock(&wayland_lock);
+		return NULL;
+	}
+
+	int n = strlen(snarf);
+	char *copy = calloc(1, n+1);
+	strncpy(copy, snarf, n);
+	qunlock(&wayland_lock);
+	return copy;
+}
+
+void	rpc_putsnarf(char *snarf_in) {
+	DEBUG("rpc_putsnarf\n");
+	qlock(&wayland_lock);
+
+	int n = strlen(snarf_in);
+	free(snarf);
+	snarf = calloc(1, n+1);
+	strncpy(snarf, snarf_in, n);
+
+	struct wl_data_source *source =
+		wl_data_device_manager_create_data_source(wl_data_device_manager);
+	wl_data_source_add_listener(source, &wl_data_source_listener, NULL);
+	wl_data_source_offer(source, "text/plain");
+	wl_data_device_set_selection(wl_data_device, source, keyboard_enter_serial);
+
+	qunlock(&wayland_lock);
+}
+
+void	rpc_shutdown(void) {
+	DEBUG("rpc_shutdown\n");
+}
+
+void rpc_gfxdrawlock(void) {
+	qlock(&wayland_lock);
+}
+
+void rpc_gfxdrawunlock(void) {
+	qunlock(&wayland_lock);
+}
+
+int cloadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata) {
+	return _cloadmemimage(i, r, data, ndata);
+}
+
+int loadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata) {
+	return _loadmemimage(i, r, data, ndata);
+}
+
+int unloadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata) {
+	return _unloadmemimage(i, r, data, ndata);
+}
diff --git a/src/cmd/fontsrv/freetyperules.sh b/src/cmd/fontsrv/freetyperules.sh
index 5ca91573..ed2c9b0e 100644
--- a/src/cmd/fontsrv/freetyperules.sh
+++ b/src/cmd/fontsrv/freetyperules.sh
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-if [ "x$1" = "xx11" ]; then
+if [ "x$1" = "xx11" -o "x$1" = "xwayland" ]; then
 	if [ "x$2" = "x" ]; then
 		i="-I/usr/include"
 	else
diff --git a/src/cmd/fontsrv/mkfile b/src/cmd/fontsrv/mkfile
index 218b7c73..60d6115e 100644
--- a/src/cmd/fontsrv/mkfile
+++ b/src/cmd/fontsrv/mkfile
@@ -1,6 +1,6 @@
 <$PLAN9/src/mkhdr
 <|osxvers
-<|sh ../devdraw/mkwsysrules.sh
+<|sh mkwsysrules.sh
 <|sh freetyperules.sh $WSYSTYPE $X11H
 
 TARG=fontsrv
diff --git a/src/cmd/fontsrv/mkwsysrules.sh b/src/cmd/fontsrv/mkwsysrules.sh
new file mode 100644
index 00000000..a8cf5954
--- /dev/null
+++ b/src/cmd/fontsrv/mkwsysrules.sh
@@ -0,0 +1,63 @@
+#!/bin/sh
+
+[ -f $PLAN9/config ] && . $PLAN9/config
+
+if [ "x$X11" = "x" ]; then
+	if [ -d /usr/X11R6 ]; then
+		X11=/usr/X11R6
+	elif [ -d /usr/local/X11R6 ]; then
+		X11=/usr/local/X11R6
+	elif [ -d /usr/X11R7 ]; then
+		X11=/usr/X11R7
+	elif [ -d /usr/X ]; then
+		X11=/usr/X
+	elif [ -d /usr/openwin ]; then	# for Sun
+		X11=/usr/openwin
+	elif [ -d /usr/include/X11 ]; then
+		X11=/usr
+	elif [ -d /usr/local/include/X11 ]; then
+		X11=/usr/local
+	else
+		X11=noX11dir
+	fi
+fi
+
+if [ "x$WSYSTYPE" = "x" ]; then
+	if [ "x`uname`" = "xDarwin" ]; then
+		if sw_vers | egrep 'ProductVersion:	(10\.[0-9]\.|10\.1[012])$' >/dev/null; then
+			echo 1>&2 'OS X 10.12 and older are not supported'
+			exit 1
+		fi
+		WSYSTYPE=mac
+	elif [ -d "$X11" ]; then
+		WSYSTYPE=x11
+	else
+		WSYSTYPE=nowsys
+	fi
+fi
+
+if [ "x$WSYSTYPE" = "xx11" -a "x$X11H" = "x" ]; then
+	if [ -d "$X11/include" ]; then
+		X11H="-I$X11/include"
+	else
+		X11H=""
+	fi
+fi
+
+echo 'WSYSTYPE='$WSYSTYPE
+echo 'X11='$X11
+echo 'X11H='$X11H
+
+if [ $WSYSTYPE = x11 -o $WSYSTYPE = wayland ]; then
+	echo 'CFLAGS=$CFLAGS '$X11H
+	echo 'HFILES=$HFILES $XHFILES'
+	XO=`ls x11-*.c 2>/dev/null | sed 's/\.c$/.o/'`
+	echo 'WSYSOFILES=$WSYSOFILES '$XO
+	echo 'WSYSHFILES=x11-inc.h x11-keysym2ucs.h x11-memdraw.h'
+elif [ $WSYSTYPE = mac ]; then
+	echo 'WSYSOFILES=$WSYSOFILES mac-draw.o mac-screen.o'
+	echo 'WSYSHFILES='
+	echo 'MACARGV=macargv.o'
+elif [ $WSYSTYPE = nowsys ]; then
+	echo 'WSYSOFILES=nowsys.o'
+fi
diff --git a/src/cmd/fontsrv/wayland.c b/src/cmd/fontsrv/wayland.c
new file mode 100644
index 00000000..f10d3b6b
--- /dev/null
+++ b/src/cmd/fontsrv/wayland.c
@@ -0,0 +1,3 @@
+// note: the fontsrv implementation for X11 and wayland are the same.
+// this non-standard include is an alternative to copying the file.
+#include "x11.c"
