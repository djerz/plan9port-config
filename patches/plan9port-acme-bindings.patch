diff --git a/man/man1/acme.1 b/man/man1/acme.1
index 852a8f7f..94683acd 100644
--- a/man/man1/acme.1
+++ b/man/man1/acme.1
@@ -662,12 +662,13 @@ a chord, so that for example on Macs selecting text with the trackpad
 button and then typing Option without letting go of the button will
 cause a 1-2 chord, cutting the selection.
 On Mac systems, the usual keyboard shortcuts
-Command-C, -V, -X, and -Z invoke
-copy, paste, cut, and undo,
+Command-A, Command-C, -S, -V, -X, and -Z invoke
+select all, copy, save, paste, cut, and undo,
 and Command-Shift-Z invokes redo,
 as in other programs.
 Especially on Mac laptops, these keyboard shortcuts are
 typically much less awkward than the equivalent chords.
+Also, on Mac laptops, Command-\\ executes text like button 2.
 .SS "Support programs
 .I Win
 creates a new
diff --git a/src/cmd/acme/fns.h b/src/cmd/acme/fns.h
index 969db417..79caca8b 100644
--- a/src/cmd/acme/fns.h
+++ b/src/cmd/acme/fns.h
@@ -107,3 +107,5 @@ Range range(int, int);
 #define	runemove(a, b, c)	memmove((a), (b), (c)*sizeof(Rune))
 
 int	ismtpt(char*);
+
+int	isexecc(int);
diff --git a/src/cmd/acme/text.c b/src/cmd/acme/text.c
index 09422dda..5cec0fbd 100644
--- a/src/cmd/acme/text.c
+++ b/src/cmd/acme/text.c
@@ -15,6 +15,7 @@
 
 Image	*tagcols[NCOL];
 Image	*textcols[NCOL];
+static Rune LDel[] = { 'D', 'e', 'l', 0 };
 static Rune Ldot[] = { '.', 0 };
 
 enum{
@@ -563,6 +564,28 @@ textbswidth(Text *t, Rune c)
 	return t->q0-q;
 }
 
+/* erase to end of line version of textbswidth */
+int
+textfewidth(Text *t, Rune c)
+{
+	uint q, eq;
+	Rune r;
+	int skipping;
+
+	q = t->q0;
+	skipping = TRUE;
+	while(q < t->file->b.nc){
+		r = textreadc(t, q);
+		if(r == '\n'){          /* eat at most one more character */
+			if(q == t->q0)  /* eat the newline */
+				++q;
+			break;
+		}
+		++q;
+	}
+	return q-t->q0;
+}
+
 int
 textfilewidth(Text *t, uint q0, int oneelement)
 {
@@ -664,6 +687,20 @@ textcomplete(Text *t)
 	return rp;
 }
 
+/* copy of same function from src/cmd/acme/look.c */
+static int
+texthas(Text *t, uint q0, Rune *r)
+{
+	int i;
+
+	if((int)q0 < 0)
+		return FALSE;
+	for(i=0; r[i]; i++)
+		if(q0+i >= t->file->b.nc || textreadc(t, q0+i) != r[i])
+			return FALSE;
+	return TRUE;
+}
+
 void
 texttype(Text *t, Rune r)
 {
@@ -672,6 +709,7 @@ texttype(Text *t, Rune r)
 	int nr;
 	Rune *rp;
 	Text *u;
+	Rune c;
 
 	if(t->what!=Body && t->what!=Tag && r=='\n')
 		return;
@@ -760,10 +798,52 @@ texttype(Text *t, Rune r)
 			q0++;
 		textshow(t, q0, q0, TRUE);
 		return;
+	case 0x0E:	/* ^N: move one line down */
+		typecommit(t);
+		q0 = t->q0;
+		nnb = 0;
+		if(q0>0 && textreadc(t, q0-1)!='\n')
+			nnb = textbswidth(t, 0x15);
+		while(q0<t->file->b.nc && textreadc(t, q0)!='\n')
+			q0++;
+		if (q0+1 <= t->file->b.nc)
+			q0++;
+		while(q0<t->file->b.nc && textreadc(t, q0)!='\n' && nnb--)
+			q0++;
+		textshow(t, q0, q0, TRUE);
+		return;
+	case 0x10:	/* ^P: move one line up */
+		typecommit(t);
+		q0 = t->q0;
+		nnb = 0;
+		n = 0;
+		if(q0>0 && textreadc(t, q0-1)!='\n')
+			nnb = textbswidth(t, 0x15);
+		q0 -= nnb;
+		if (q0>0)
+			q0--;
+		while (q0>0 && textreadc(t, q0-1)!='\n')
+			if (q0 == 0)
+				break;
+			else {
+				q0--;
+				n++;
+			}
+		q0 += (nnb > n) ? n : nnb;
+		textshow(t, q0, q0, TRUE);
+		return;
+	case Kcmd+'a':	/* %A: select all */
+		typecommit(t);
+		textshow(t, 0, t->file->b.nc, TRUE);
+		return;
 	case Kcmd+'c':	/* %C: copy */
 		typecommit(t);
 		cut(t, t, nil, TRUE, FALSE, nil, 0);
 		return;
+	case Kcmd+'s':	/* %S: save */
+		typecommit(t);
+		put(&(t->w)->body, nil, nil, XXX, XXX, nil, 0);
+		return;
 	case Kcmd+'z':	/* %Z: undo */
 	 	typecommit(t);
 		undo(t, nil, nil, TRUE, 0, nil, 0);
@@ -772,6 +852,28 @@ texttype(Text *t, Rune r)
 	 	typecommit(t);
 		undo(t, nil, nil, FALSE, 0, nil, 0);
 		return;
+	case Kcmd+'\\':	/* %\: execute */
+		typecommit(t);
+		q0 = t->q0;
+		q1 = t->q1;
+		/* replicated logic from src/cmd/acme/look.c */
+		if(q1 == q0){	/* expand to find word (actually file name) */
+			/* if in selection, choose selection */
+			if(t->q1>t->q0 && t->q0<=q0 && q0<=t->q1){
+				q0 = t->q0;
+				q1 = t->q1;
+			}else{
+				while(q1<t->file->b.nc && isexecc(c=textreadc(t, q1)) && c!=':')
+					q1++;
+				while(q0>0 && isexecc(c=textreadc(t, q0-1)) && c!=':')
+					q0--;
+			}
+		}
+		if(texthas(t, q0, LDel))
+			warning(nil, "Del , Delete , Delcol , ... must be executed with mouse\n");
+		else
+			execute(t, q0, q1, FALSE, nil);
+		return;
 
 	Tagdown:
 		/* expand tag to show all text */
@@ -847,11 +949,20 @@ texttype(Text *t, Rune r)
 	case 0x08:	/* ^H: erase character */
 	case 0x15:	/* ^U: erase line */
 	case 0x17:	/* ^W: erase word */
-		if(t->q0 == 0)	/* nothing to erase */
-			return;
-		nnb = textbswidth(t, r);
-		q1 = t->q0;
-		q0 = q1-nnb;
+	case 0x0B:      /* ^K: forward erase line */
+		if(r == 0x0B){
+			typecommit(t);
+			nnb = textfewidth(t, r);
+			q0 = t->q0;
+			q1 = q0+nnb;
+			textshow(t, q1, q1, TRUE);
+		}else{
+			if(t->q0 == 0)	/* nothing to erase */
+				return;
+			nnb = textbswidth(t, r);
+			q1 = t->q0;
+			q0 = q1-nnb;
+		}
 		/* if selection is at beginning of window, avoid deleting invisible text */
 		if(q0 < t->org){
 			q0 = t->org;
